
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.0">
    
    
      
        <title>Test wrapped hypot test gen - rna_predict</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.618322db.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#-test_testgenerator_generate_test_variants_basicpy-" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="rna_predict" class="md-header__button md-logo" aria-label="rna_predict" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            rna_predict
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Test wrapped hypot test gen
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="rna_predict" class="md-nav__button md-logo" aria-label="rna_predict" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    rna_predict
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Guides
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Guides
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1" >
        
          
          <label class="md-nav__link" for="__nav_2_1" id="__nav_2_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Getting Started
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Getting Started
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../guides/getting_started/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Overview
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../guides/getting_started/windows_compatibility_plan/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Windows Compatibility
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Best Practices
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Best Practices
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../guides/best_practices/code_quality_best_practices/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Code Quality
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2_2" id="__nav_2_2_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Testing
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Testing
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../guides/best_practices/testing/test_coverage_strategy/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Coverage Strategy
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../guides/best_practices/testing/progressive_coverage/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Progressive Coverage
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../guides/best_practices/testing/test_generation_prompt/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Test Generation
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_2_3" id="__nav_2_2_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Debugging
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_2_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Debugging
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../guides/best_practices/debugging/comprehensive_debugging_guide/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Comprehensive Guide
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Pipeline
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Pipeline
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Overview
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Overview
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/overview/core_framework/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Core Framework
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/overview/Integrated_RNA_3D_Prediction_Pipeline_Final_Comprehensive_Design/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Comprehensive Design
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/overview/full_pipeline_specification/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Full Specification
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/overview/Multi_Stage_Implementation_Plan/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Multi-Stage Plan
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Integration
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Integration
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/integration/Integrated_RNA_3D_Prediction_Pipeline_Final_Comprehensive_Design/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Design
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/integration/full_pipeline_specification/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Full Specification
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2_3" >
        
          
          <label class="md-nav__link" for="__nav_3_2_3" id="__nav_3_2_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Hydra Integration
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Hydra Integration
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/integration/hydra_integration/hydra_tutorial/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Tutorial
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/integration/hydra_integration/hydra_integration_gap_analysis/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Gap Analysis
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/integration/hydra_integration/hydra_integration_master_document/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Master Document
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2_3_4" >
        
          
          <label class="md-nav__link" for="__nav_3_2_3_4" id="__nav_3_2_3_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Components
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_3_2_3_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2_3_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    Components
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/integration/hydra_integration/components/stageA/StageA_2D_Adjacency/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Stage A
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/integration/hydra_integration/components/stageB/StageB_Torsion_Pairwise/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Stage B
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/integration/hydra_integration/components/stageC/StageC_3D_Reconstruction/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Stage C
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/integration/hydra_integration/components/stageD/StageD_Diffusion_Refinement/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Stage D
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/integration/hydra_integration/components/unified_latent/UnifiedLatentMerger/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Unified Latent
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Stage A
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Stage A
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/stageA/StageA_RFold/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Overview
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/stageA/RFold_code/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    RFold Code
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/stageA/RFold_paper/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    RFold Paper
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/stageA/rfold-demo/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Demo
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/stageA/stage_a_extra/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Extra Notes
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_4" >
        
          
          <label class="md-nav__link" for="__nav_3_4" id="__nav_3_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Stage B
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    Stage B
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/stageB/Stage_B/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Overview
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_4_2" >
        
          
          <label class="md-nav__link" for="__nav_3_4_2" id="__nav_3_4_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    TorsionBERT
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_4_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_4_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    TorsionBERT
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/stageB/torsionBert/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Overview
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/stageB/torsionbert_code/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Code
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/stageB/torsionBert_full_paper/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Paper
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_5" >
        
          
          <label class="md-nav__link" for="__nav_3_5" id="__nav_3_5_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Stage C
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_5">
            <span class="md-nav__icon md-icon"></span>
            
  
    Stage C
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/stageC/Stage_C/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Overview
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/stageC/Integrated_RNA_Geometry_and_3D_Reconstruction/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Geometry & Reconstruction
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/stageC/Unified, Comprehensive Plan for Integrating MP-NeRF into Stage C.md" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MP-NeRF Integration
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/stageC/mp_nerf/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    MP-NeRF Details
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_6" >
        
          
          <label class="md-nav__link" for="__nav_3_6" id="__nav_3_6_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Unified Latent
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_6">
            <span class="md-nav__icon md-icon"></span>
            
  
    Unified Latent
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/unified_latent/Perceiver_IO/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Perceiver IO
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/Energy_Minimization_%26_Molecular_Dynamics_%28MD%29_for_RNA_Structure_Refinement/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Energy & MD
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_8" >
        
          
          <label class="md-nav__link" for="__nav_3_8" id="__nav_3_8_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Testing
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_8">
            <span class="md-nav__icon md-icon"></span>
            
  
    Testing
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/test_time_scaling/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Time Scaling
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_9" >
        
          
          <label class="md-nav__link" for="__nav_3_9" id="__nav_3_9_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Kaggle
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_9_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_9">
            <span class="md-nav__icon md-icon"></span>
            
  
    Kaggle
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/kaggle_info/kaggle_competition/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Competition
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../pipeline/kaggle_info/M2_Plan/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    M2 Plan
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Reference
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    Reference
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1" >
        
          
          <label class="md-nav__link" for="__nav_4_1" id="__nav_4_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Advanced Methods
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    Advanced Methods
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1_1" >
        
          
          <label class="md-nav__link" for="__nav_4_1_1" id="__nav_4_1_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    AlphaFold 3
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_1_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1_1">
            <span class="md-nav__icon md-icon"></span>
            
  
    AlphaFold 3
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/advanced_methods/af3/AF3_paper/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Paper
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/advanced_methods/af3/AlphaFold3_progress/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Progress
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/advanced_methods/af3/Pairwise_Distance_Based_Prediction/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Distance Prediction
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1_2" >
        
          
          <label class="md-nav__link" for="__nav_4_1_2" id="__nav_4_1_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Diffusion
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_1_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_1_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    Diffusion
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/advanced_methods/diffusion/s4_diffusion/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    S4 Diffusion
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/advanced_methods/diffusion/test_time_scaling/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Time Scaling
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/advanced_methods/isosteric_substitutions/RNA_isostericity/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Isosteric Substitutions
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_2" >
        
          
          <label class="md-nav__link" for="__nav_4_2" id="__nav_4_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    External Literature
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_2">
            <span class="md-nav__icon md-icon"></span>
            
  
    External Literature
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/external_lit/2d_structure_prediction_papers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    2D Structure
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/external_lit/RNA_papers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    RNA Papers
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_3" >
        
          
          <label class="md-nav__link" for="__nav_4_3" id="__nav_4_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Residue Atom Bridging
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_3">
            <span class="md-nav__icon md-icon"></span>
            
  
    Residue Atom Bridging
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/residue_atom_bridging/audit_report/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Audit Report
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/residue_atom_bridging/design_spec/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Design Spec
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/residue_atom_bridging/documentation_draft/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Documentation
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/residue_atom_bridging/implementation_notes/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Implementation
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/residue_atom_bridging/refactoring_plan/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Refactoring
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/residue_atom_bridging/bridging_caveats_guidelines/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Guidelines
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_4" >
        
          
          <label class="md-nav__link" for="__nav_4_4" id="__nav_4_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    
  
    Torsion Calculations
  

    
  </span>
  
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4_4">
            <span class="md-nav__icon md-icon"></span>
            
  
    Torsion Calculations
  

          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/torsion_calculations/torsion_angles_intro/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Introduction
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/torsion_calculations/Standard_Bond_Lengths_and_Angles_in_RNA_Nucleotides/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Bond Lengths & Angles
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/torsion_calculations/Torsion_Angles_3D_Coordinates_RNA_Structure/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    3D Coordinates
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../reference/torsion_calculations/torsion_angle_Latent_Manifold_Representation/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Latent Manifold
  

    
  </span>
  
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<p>You are given one or more automatically generated Python test files that test various classes and functions. These tests may have issues such as poor naming conventions, inconsistent usage of self, lack of setUp methods, minimal docstrings, redundant or duplicate tests, and limited assertion coverage. They may also fail to leverage hypothesis and unittest.mock effectively, and might not be logically grouped.</p>
<p>Your task is to produce a single, consolidated, high-quality test file from the given input files. The refactored test file should incorporate the following improvements:
    1.  Consolidation and Organization
       Combine all tests from the provided files into one coherent Python test file.
       Group tests into classes that correspond logically to the functionality they are testing (e.g., separate test classes by the class or function under test).
       Within each class, order test methods logically (e.g., basic functionality first, edge cases, error handling, round-trip tests afterward).
    2.  Clean, Readable Code
       Use descriptive, PEP 8-compliant class and method names.
       Add docstrings to each test class and test method, explaining their purpose and what they verify.
       Remove redundant, duplicate, or meaningless tests. Combine or refactor tests that cover the same functionality into a single, comprehensive test method when appropriate.
    3.  Proper Test Fixtures
       Utilize setUp methods to instantiate commonly used objects before each test method, reducing redundancy.
       Ensure that instance methods of classes under test are called on properly instantiated objects rather than passing self incorrectly as an argument.
    4.  Robust Assertions and Coverage
       Include multiple assertions in each test to thoroughly verify behavior and correctness.
       Use unittests assertRaises for expected exceptions to validate error handling.
       Implement at least one round-trip test (e.g., encode then decode a data structure, or transform an object multiple times to ensure idempotency).
    5.  Effective Use of Hypothesis
       Employ hypothesis to generate a wide range of input data, ensuring better coverage and exposing edge cases.
       Use strategies like st.builds to create complex objects (e.g., custom dataclasses) with varied attribute values.
       Enforce constraints (e.g., allow_nan=False) to avoid nonsensical test inputs.
    6.  Mocking External Dependencies
       Use unittest.mock where appropriate to simulate external dependencies or environments, ensuring tests are reliable and isolated from external conditions.</p>
<p></p>
<p>Additional Context: Getting Started with Hypothesis</p>
<p>Below is a practical guide that outlines common use cases and best practices for leveraging hypothesis:
    1.  Basic Usage
       Decorate test functions with @given and specify a strategy (e.g., @given(st.text())).
       Let hypothesis generate diverse test cases automatically.
    2.  Common Strategies
       Use built-in strategies like st.integers(), st.floats(), st.text(), etc.
       Combine strategies with st.lists, st.builds, or st.composite to generate complex objects.
    3.  Composing Tests
       Employ assume() to filter out unwanted test cases.
       Compose or build custom objects to test domain-specific logic.
    4.  Advanced Features
       Fine-tune test runs with @settings (e.g., max_examples=1000).
       Create reusable strategies via @composite.
    5.  Best Practices
       Keep tests focused on one property at a time.
       Use explicit examples with @example() for edge cases.
       Manage performance by choosing realistic strategy bounds.
    6.  Debugging Failed Tests
       Hypothesis shows minimal failing examples and seeds to help reproduce and fix issues.</p>
<p></p>
<p>Input Format</p>
<p>TEST CODE: </p>
<h1 id="-test_testgenerator_generate_test_variants_basicpy-">----- test_TestGenerator_generate_test_variants_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorgenerate_Test_Variants(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())))
def test_fuzz_TestGenerator_generate_test_variants(self, entity: hypot_test_gen.TestableEntity) -&gt; None:
    hypot_test_gen.TestGenerator.generate_test_variants(self=self, entity=entity)
</code></pre></div>
<h1 id="-test_testgenerator_write_and_verify_output_errorspy-">----- test_TestGenerator_write_and_verify_output_errors.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, reject, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorwrite_And_Verify_Output(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), output_file=st.from_type(pathlib.Path), content=st.text())
def test_fuzz_TestGenerator_write_and_verify_output(self, output_file: pathlib.Path, content: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.write_and_verify_output(self=self, output_file=output_file, content=content)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_process_entities_idempotentpy-">----- test_TestGenerator_process_entities_idempotent.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestIdempotentTestgeneratorprocess_Entities(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entities=st.lists(st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text()))), total_variants=st.integers(), module_path=st.text())
def test_idempotent_TestGenerator_process_entities(self, entities: typing.List[hypot_test_gen.TestableEntity], total_variants: int, module_path: str) -&gt; None:
    result = hypot_test_gen.TestGenerator.process_entities(self=self, entities=entities, total_variants=total_variants, module_path=module_path)
    repeat = hypot_test_gen.TestGenerator.process_entities(self=result, entities=entities, total_variants=total_variants, module_path=module_path)
    self.assertEqual(result, repeat)
</code></pre></div>
<h1 id="-test_testgenerator_handle_generated_output_errorspy-">----- test_TestGenerator_handle_generated_output_errors.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorhandle_Generated_Output(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())), variant=st.dictionaries(keys=st.text(), values=st.text()), output=st.text())
def test_fuzz_TestGenerator_handle_generated_output(self, entity: hypot_test_gen.TestableEntity, variant: typing.Dict[str, str], output: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.handle_generated_output(self=self, entity=entity, variant=variant, output=output)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_process_hypothesis_result_idempotentpy-">----- test_TestGenerator_process_hypothesis_result_idempotent.py -----</h1>
<p>import hypot_test_gen
import subprocess
import unittest
from hypothesis import given, strategies as st
from subprocess import CompletedProcess</p>
<p>class TestIdempotentTestgeneratorprocess_Hypothesis_Result(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), result=st.from_type(subprocess.CompletedProcess))
def test_idempotent_TestGenerator_process_hypothesis_result(self, result: subprocess.CompletedProcess) -&gt; None:
    result = hypot_test_gen.TestGenerator.process_hypothesis_result(self=self, result=result)
    repeat = hypot_test_gen.TestGenerator.process_hypothesis_result(self=result, result=result)
    self.assertEqual(result, repeat)
</code></pre></div>
<h1 id="-test_testgenerator_extract_imports_errorspy-">----- test_TestGenerator_extract_imports_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorextract_Imports(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), content=st.text())
def test_fuzz_TestGenerator_extract_imports(self, content: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.extract_imports(self=self, content=content)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_process_method_errorspy-">----- test_ModuleParser_process_method_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzModuleparserprocess_Method(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_ModuleParser_process_method(self, node: ast.FunctionDef) -&gt; None:
    try:
        hypot_test_gen.ModuleParser.process_method(self=self, node=node)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_generate_test_variants_errorspy-">----- test_TestGenerator_generate_test_variants_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorgenerate_Test_Variants(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())))
def test_fuzz_TestGenerator_generate_test_variants(self, entity: hypot_test_gen.TestableEntity) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.generate_test_variants(self=self, entity=entity)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testfixer_visit_functiondef_errorspy-">----- test_TestFixer_visit_FunctionDef_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestfixervisit_Functiondef(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_TestFixer_visit_FunctionDef(self, node: ast.FunctionDef) -&gt; None:
    try:
        hypot_test_gen.TestFixer.visit_FunctionDef(self=self, node=node)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_verify_output_dir_validationpy-">----- test_TestGenerator_verify_output_dir_validation.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorverify_Output_Dir(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_verify_output_dir(self) -&gt; None:
    hypot_test_gen.TestGenerator.verify_output_dir(self=self)
</code></pre></div>
<h1 id="-test_moduleparser_get_base_name_basicpy-">----- test_ModuleParser_get_base_name_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import AST
from hypothesis import given, strategies as st</p>
<p>class TestFuzzModuleparserget_Base_Name(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), base=st.builds(AST))
def test_fuzz_ModuleParser_get_base_name(self, base: ast.AST) -&gt; None:
    hypot_test_gen.ModuleParser.get_base_name(self=self, base=base)
</code></pre></div>
<h1 id="-test_fix_pythonpath_basicpy-">----- test_fix_pythonpath_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzFix_Pythonpath(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(file_path=st.from_type(pathlib.Path))
def test_fuzz_fix_pythonpath(self, file_path: pathlib.Path) -&gt; None:
    hypot_test_gen.fix_pythonpath(file_path=file_path)
</code></pre></div>
<h1 id="-test_testgenerator_verify_output_dir_basicpy-">----- test_TestGenerator_verify_output_dir_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorverify_Output_Dir(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_verify_output_dir(self) -&gt; None:
    hypot_test_gen.TestGenerator.verify_output_dir(self=self)
</code></pre></div>
<h1 id="-test_testgenerator_log_environment_errorspy-">----- test_TestGenerator_log_environment_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorlog_Environment(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_log_environment(self) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.log_environment(self=self)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_prepare_environment_errorspy-">----- test_TestGenerator_prepare_environment_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorprepare_Environment(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_prepare_environment(self) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.prepare_environment(self=self)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_remove_logger_lines_basicpy-">----- test_remove_logger_lines_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzRemove_Logger_Lines(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(text=st.text())
def test_fuzz_remove_logger_lines(self, text: str) -&gt; None:
    hypot_test_gen.remove_logger_lines(text=text)
</code></pre></div>
<h1 id="-test_construct_src_path_basicpy-">----- test_construct_src_path_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzConstruct_Src_Path(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(file_path=st.from_type(pathlib.Path))
def test_fuzz_construct_src_path(self, file_path: pathlib.Path) -&gt; None:
    hypot_test_gen.construct_src_path(file_path=file_path)
</code></pre></div>
<h1 id="-test_debug_command_output_basicpy-">----- test_debug_command_output_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzDebug_Command_Output(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(cmd=st.text(), stdout=st.text(), stderr=st.text(), returncode=st.integers())
def test_fuzz_debug_command_output(self, cmd: str, stdout: str, stderr: str, returncode: int) -&gt; None:
    hypot_test_gen.debug_command_output(cmd=cmd, stdout=stdout, stderr=stderr, returncode=returncode)
</code></pre></div>
<h1 id="-test_parse_args_basicpy-">----- test_parse_args_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzParse_Args(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(args=st.one_of(st.none(), st.builds(list)))
def test_fuzz_parse_args(self, args: typing.Optional[list]) -&gt; None:
    hypot_test_gen.parse_args(args=args)
</code></pre></div>
<h1 id="-test_testgenerator_get_module_contents_basicpy-">----- test_TestGenerator_get_module_contents_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorget_Module_Contents(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), file_path=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator_get_module_contents(self, file_path: pathlib.Path) -&gt; None:
    hypot_test_gen.TestGenerator.get_module_contents(self=self, file_path=file_path)
</code></pre></div>
<h1 id="-test_moduleparser_process_method_basicpy-">----- test_ModuleParser_process_method_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, strategies as st</p>
<p>class TestFuzzModuleparserprocess_Method(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_ModuleParser_process_method(self, node: ast.FunctionDef) -&gt; None:
    hypot_test_gen.ModuleParser.process_method(self=self, node=node)
</code></pre></div>
<h1 id="-test_testgenerator_combine_and_cleanup_tests_basicpy-">----- test_TestGenerator_combine_and_cleanup_tests_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorcombine_And_Cleanup_Tests(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), file_path=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator_combine_and_cleanup_tests(self, file_path: pathlib.Path) -&gt; None:
    hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=self, file_path=file_path)
</code></pre></div>
<h1 id="-test_testgenerator_generate_all_tests_basicpy-">----- test_TestGenerator_generate_all_tests_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorgenerate_All_Tests(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), file_path=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator_generate_all_tests(self, file_path: pathlib.Path) -&gt; None:
    hypot_test_gen.TestGenerator.generate_all_tests(self=self, file_path=file_path)
</code></pre></div>
<h1 id="-test_testgenerator_try_generate_test_basicpy-">----- test_TestGenerator_try_generate_test_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratortry_Generate_Test(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())), variant=st.dictionaries(keys=st.text(), values=st.text()), max_retries=st.integers())
def test_fuzz_TestGenerator_try_generate_test(self, entity: hypot_test_gen.TestableEntity, variant: typing.Dict[str, str], max_retries: int) -&gt; None:
    hypot_test_gen.TestGenerator.try_generate_test(self=self, entity=entity, variant=variant, max_retries=max_retries)
</code></pre></div>
<h1 id="-test_moduleparser_add_function_entity_basicpy-">----- test_ModuleParser_add_function_entity_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, strategies as st</p>
<p>class TestFuzzModuleparseradd_Function_Entity(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_ModuleParser_add_function_entity(self, node: ast.FunctionDef) -&gt; None:
    hypot_test_gen.ModuleParser.add_function_entity(self=self, node=node)
</code></pre></div>
<h1 id="-test_testgenerator_populate_entities_basicpy-">----- test_TestGenerator_populate_entities_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypot_test_gen import ModuleParser
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorpopulate_Entities(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), parser=st.builds(ModuleParser), module_path=st.text())
def test_fuzz_TestGenerator_populate_entities(self, parser: hypot_test_gen.ModuleParser, module_path: str) -&gt; None:
    hypot_test_gen.TestGenerator.populate_entities(self=self, parser=parser, module_path=module_path)
</code></pre></div>
<h1 id="-test_fix_leading_zeros_basicpy-">----- test_fix_leading_zeros_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzFix_Leading_Zeros(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(test_code=st.text())
def test_fuzz_fix_leading_zeros(self, test_code: str) -&gt; None:
    hypot_test_gen.fix_leading_zeros(test_code=test_code)
</code></pre></div>
<h1 id="-test_testgenerator_construct_module_path_errorspy-">----- test_TestGenerator_construct_module_path_errors.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, reject, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorconstruct_Module_Path(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), file_path=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator_construct_module_path(self, file_path: pathlib.Path) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.construct_module_path(self=self, file_path=file_path)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_get_module_contents_errorspy-">----- test_TestGenerator_get_module_contents_errors.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, reject, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorget_Module_Contents(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), file_path=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator_get_module_contents(self, file_path: pathlib.Path) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.get_module_contents(self=self, file_path=file_path)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_create_variant_basicpy-">----- test_TestGenerator_create_variant_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorcreate_Variant(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), variant_type=st.text(), cmd=st.text())
def test_fuzz_TestGenerator_create_variant(self, variant_type: str, cmd: str) -&gt; None:
    hypot_test_gen.TestGenerator.create_variant(self=self, variant_type=variant_type, cmd=cmd)
</code></pre></div>
<h1 id="-test_run_test_generation_basicpy-">----- test_run_test_generation_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import typing
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzRun_Test_Generation(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(file_path=st.from_type(typing.Union[str, pathlib.Path]))
def test_fuzz_run_test_generation(self, file_path: typing.Union[str, pathlib.Path]) -&gt; None:
    hypot_test_gen.run_test_generation(file_path=file_path)
</code></pre></div>
<h1 id="-test_testgenerator_construct_module_path_basicpy-">----- test_TestGenerator_construct_module_path_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorconstruct_Module_Path(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), file_path=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator_construct_module_path(self, file_path: pathlib.Path) -&gt; None:
    hypot_test_gen.TestGenerator.construct_module_path(self=self, file_path=file_path)
</code></pre></div>
<h1 id="-test_moduleparser_add_class_entity_basicpy-">----- test_ModuleParser_add_class_entity_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import ClassDef
from hypothesis import given, strategies as st</p>
<p>class TestFuzzModuleparseradd_Class_Entity(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(ClassDef))
def test_fuzz_ModuleParser_add_class_entity(self, node: ast.ClassDef) -&gt; None:
    hypot_test_gen.ModuleParser.add_class_entity(self=self, node=node)
</code></pre></div>
<h1 id="-test_testgenerator_extract_imports_basicpy-">----- test_TestGenerator_extract_imports_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorextract_Imports(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), content=st.text())
def test_fuzz_TestGenerator_extract_imports(self, content: str) -&gt; None:
    hypot_test_gen.TestGenerator.extract_imports(self=self, content=content)
</code></pre></div>
<h1 id="-test_testfixer_visit_functiondef_basicpy-">----- test_TestFixer_visit_FunctionDef_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestfixervisit_Functiondef(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_TestFixer_visit_FunctionDef(self, node: ast.FunctionDef) -&gt; None:
    hypot_test_gen.TestFixer.visit_FunctionDef(self=self, node=node)
</code></pre></div>
<h1 id="-test_testgenerator_write_and_verify_output_validationpy-">----- test_TestGenerator_write_and_verify_output_validation.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorwrite_And_Verify_Output(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), output_file=st.from_type(pathlib.Path), content=st.text())
def test_fuzz_TestGenerator_write_and_verify_output(self, output_file: pathlib.Path, content: str) -&gt; None:
    hypot_test_gen.TestGenerator.write_and_verify_output(self=self, output_file=output_file, content=content)
</code></pre></div>
<h1 id="-test_testgenerator_wrap_with_prompt_errorspy-">----- test_TestGenerator_wrap_with_prompt_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorwrap_With_Prompt(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), combined_test_code=st.text(), original_source_code=st.text())
def test_fuzz_TestGenerator_wrap_with_prompt(self, combined_test_code: str, original_source_code: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.wrap_with_prompt(self=self, combined_test_code=combined_test_code, original_source_code=original_source_code)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_combine_and_cleanup_tests_errorspy-">----- test_TestGenerator_combine_and_cleanup_tests_errors.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, reject, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorcombine_And_Cleanup_Tests(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), file_path=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator_combine_and_cleanup_tests(self, file_path: pathlib.Path) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=self, file_path=file_path)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_get_base_name_errorspy-">----- test_ModuleParser_get_base_name_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import AST
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzModuleparserget_Base_Name(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), base=st.builds(AST))
def test_fuzz_ModuleParser_get_base_name(self, base: ast.AST) -&gt; None:
    try:
        hypot_test_gen.ModuleParser.get_base_name(self=self, base=base)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_main_basicpy-">----- test_main_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzMain(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(args=st.one_of(st.none(), st.builds(list)))
def test_fuzz_main(self, args: typing.Optional[list]) -&gt; None:
    hypot_test_gen.main(args=args)
</code></pre></div>
<h1 id="-test_testgenerator_display_module_info_errorspy-">----- test_TestGenerator_display_module_info_errors.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratordisplay_Module_Info(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), module_path=st.text(), entities=st.lists(st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text()))))
def test_fuzz_TestGenerator_display_module_info(self, module_path: str, entities: typing.List[hypot_test_gen.TestableEntity]) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.display_module_info(self=self, module_path=module_path, entities=entities)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_prepare_environment_basicpy-">----- test_TestGenerator_prepare_environment_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorprepare_Environment(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_prepare_environment(self) -&gt; None:
    hypot_test_gen.TestGenerator.prepare_environment(self=self)
</code></pre></div>
<h1 id="-test_testgenerator_try_generate_test_errorspy-">----- test_TestGenerator_try_generate_test_errors.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratortry_Generate_Test(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())), variant=st.dictionaries(keys=st.text(), values=st.text()), max_retries=st.integers())
def test_fuzz_TestGenerator_try_generate_test(self, entity: hypot_test_gen.TestableEntity, variant: typing.Dict[str, str], max_retries: int) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.try_generate_test(self=self, entity=entity, variant=variant, max_retries=max_retries)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_generate_function_variants_errorspy-">----- test_TestGenerator_generate_function_variants_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorgenerate_Function_Variants(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())))
def test_fuzz_TestGenerator_generate_function_variants(self, entity: hypot_test_gen.TestableEntity) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.generate_function_variants(self=self, entity=entity)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_generate_function_variants_basicpy-">----- test_TestGenerator_generate_function_variants_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorgenerate_Function_Variants(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())))
def test_fuzz_TestGenerator_generate_function_variants(self, entity: hypot_test_gen.TestableEntity) -&gt; None:
    hypot_test_gen.TestGenerator.generate_function_variants(self=self, entity=entity)
</code></pre></div>
<h1 id="-test_moduleparser_add_function_entity_errorspy-">----- test_ModuleParser_add_function_entity_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzModuleparseradd_Function_Entity(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_ModuleParser_add_function_entity(self, node: ast.FunctionDef) -&gt; None:
    try:
        hypot_test_gen.ModuleParser.add_function_entity(self=self, node=node)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_add_class_entity_errorspy-">----- test_ModuleParser_add_class_entity_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import ClassDef
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzModuleparseradd_Class_Entity(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(ClassDef))
def test_fuzz_ModuleParser_add_class_entity(self, node: ast.ClassDef) -&gt; None:
    try:
        hypot_test_gen.ModuleParser.add_class_entity(self=self, node=node)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_basicpy-">----- test_TestGenerator_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgenerator(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(output_dir=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator(self, output_dir: pathlib.Path) -&gt; None:
    hypot_test_gen.TestGenerator(output_dir=output_dir)
</code></pre></div>
<h1 id="-test_testgenerator_process_entities_basicpy-">----- test_TestGenerator_process_entities_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorprocess_Entities(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entities=st.lists(st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text()))), total_variants=st.integers(), module_path=st.text())
def test_fuzz_TestGenerator_process_entities(self, entities: typing.List[hypot_test_gen.TestableEntity], total_variants: int, module_path: str) -&gt; None:
    hypot_test_gen.TestGenerator.process_entities(self=self, entities=entities, total_variants=total_variants, module_path=module_path)
</code></pre></div>
<h1 id="-test_moduleparser_determine_instance_method_errorspy-">----- test_ModuleParser_determine_instance_method_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzModuleparserdetermine_Instance_Method(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_ModuleParser_determine_instance_method(self, node: ast.FunctionDef) -&gt; None:
    try:
        hypot_test_gen.ModuleParser.determine_instance_method(self=self, node=node)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_should_skip_method_basicpy-">----- test_ModuleParser_should_skip_method_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, strategies as st</p>
<p>class TestFuzzModuleparsershould_Skip_Method(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_ModuleParser_should_skip_method(self, node: ast.FunctionDef) -&gt; None:
    hypot_test_gen.ModuleParser.should_skip_method(self=self, node=node)
</code></pre></div>
<h1 id="-test_testgenerator_process_hypothesis_result_errorspy-">----- test_TestGenerator_process_hypothesis_result_errors.py -----</h1>
<p>import hypot_test_gen
import subprocess
import unittest
from hypothesis import given, reject, strategies as st
from subprocess import CompletedProcess</p>
<p>class TestFuzzTestgeneratorprocess_Hypothesis_Result(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), result=st.from_type(subprocess.CompletedProcess))
def test_fuzz_TestGenerator_process_hypothesis_result(self, result: subprocess.CompletedProcess) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.process_hypothesis_result(self=self, result=result)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_combine_and_cleanup_tests_binary-oppy-">----- test_TestGenerator_combine_and_cleanup_tests_binary-op.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestBinaryOperationcombine_and_cleanup_tests(unittest.TestCase):
    combine_and_cleanup_tests_operands = st.from_type(pathlib.Path)</p>
<div class="highlight"><pre><span></span><code>@given(a=combine_and_cleanup_tests_operands, b=combine_and_cleanup_tests_operands, c=combine_and_cleanup_tests_operands)
def test_associative_binary_operation_TestGenerator_combine_and_cleanup_tests(self, a, b, c) -&gt; None:
    left = hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=a, file_path=hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=b, file_path=c))
    right = hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=a, file_path=b), file_path=c)
    self.assertEqual(left, right)

@given(a=combine_and_cleanup_tests_operands, b=combine_and_cleanup_tests_operands)
def test_commutative_binary_operation_TestGenerator_combine_and_cleanup_tests(self, a, b) -&gt; None:
    left = hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=a, file_path=b)
    right = hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=b, file_path=a)
    self.assertEqual(left, right)

@given(a=combine_and_cleanup_tests_operands)
def test_identity_binary_operation_TestGenerator_combine_and_cleanup_tests(self, a) -&gt; None:
    identity = PosixPath(&#39;.&#39;)
    self.assertEqual(a, hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=a, file_path=identity))
    self.assertEqual(a, hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=identity, file_path=a))
</code></pre></div>
<h1 id="-test_testgenerator_log_entities_summary_errorspy-">----- test_TestGenerator_log_entities_summary_errors.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorlog_Entities_Summary(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entities=st.lists(st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text()))))
def test_fuzz_TestGenerator_log_entities_summary(self, entities: typing.List[hypot_test_gen.TestableEntity]) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.log_entities_summary(self=self, entities=entities)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_should_skip_method_errorspy-">----- test_ModuleParser_should_skip_method_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzModuleparsershould_Skip_Method(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_ModuleParser_should_skip_method(self, node: ast.FunctionDef) -&gt; None:
    try:
        hypot_test_gen.ModuleParser.should_skip_method(self=self, node=node)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_process_class_contents_idempotentpy-">----- test_ModuleParser_process_class_contents_idempotent.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import ClassDef
from hypothesis import given, strategies as st</p>
<p>class TestIdempotentModuleparserprocess_Class_Contents(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(ClassDef))
def test_idempotent_ModuleParser_process_class_contents(self, node: ast.ClassDef) -&gt; None:
    result = hypot_test_gen.ModuleParser.process_class_contents(self=self, node=node)
    repeat = hypot_test_gen.ModuleParser.process_class_contents(self=result, node=node)
    self.assertEqual(result, repeat)
</code></pre></div>
<h1 id="-test_testgenerator_handle_failed_attempt_basicpy-">----- test_TestGenerator_handle_failed_attempt_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorhandle_Failed_Attempt(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())), variant=st.dictionaries(keys=st.text(), values=st.text()), attempt=st.integers())
def test_fuzz_TestGenerator_handle_failed_attempt(self, entity: hypot_test_gen.TestableEntity, variant: typing.Dict[str, str], attempt: int) -&gt; None:
    hypot_test_gen.TestGenerator.handle_failed_attempt(self=self, entity=entity, variant=variant, attempt=attempt)
</code></pre></div>
<h1 id="-test_testgenerator_attempt_test_generation_basicpy-">----- test_TestGenerator_attempt_test_generation_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorattempt_Test_Generation(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())), variant=st.dictionaries(keys=st.text(), values=st.text()), attempt=st.integers())
def test_fuzz_TestGenerator_attempt_test_generation(self, entity: hypot_test_gen.TestableEntity, variant: typing.Dict[str, str], attempt: int) -&gt; None:
    hypot_test_gen.TestGenerator.attempt_test_generation(self=self, entity=entity, variant=variant, attempt=attempt)
</code></pre></div>
<h1 id="-test_testgenerator_is_known_error_basicpy-">----- test_TestGenerator_is_known_error_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratoris_Known_Error(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), stderr=st.text())
def test_fuzz_TestGenerator_is_known_error(self, stderr: str) -&gt; None:
    hypot_test_gen.TestGenerator.is_known_error(self=self, stderr=stderr)
</code></pre></div>
<h1 id="-test_testgenerator_post_process_test_content_basicpy-">----- test_TestGenerator_post_process_test_content_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorpost_Process_Test_Content(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), content=st.text())
def test_fuzz_TestGenerator_post_process_test_content(self, content: str) -&gt; None:
    hypot_test_gen.TestGenerator.post_process_test_content(self=self, content=content)
</code></pre></div>
<h1 id="-test_moduleparser_add_function_entity_binary-oppy-">----- test_ModuleParser_add_function_entity_binary-op.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestBinaryOperationadd_function_entity(unittest.TestCase):
    add_function_entity_operands = st.builds(FunctionDef)</p>
<div class="highlight"><pre><span></span><code>@given(a=add_function_entity_operands, b=add_function_entity_operands, c=add_function_entity_operands)
def test_associative_binary_operation_ModuleParser_add_function_entity(self, a, b, c) -&gt; None:
    left = hypot_test_gen.ModuleParser.add_function_entity(self=a, node=hypot_test_gen.ModuleParser.add_function_entity(self=b, node=c))
    right = hypot_test_gen.ModuleParser.add_function_entity(self=hypot_test_gen.ModuleParser.add_function_entity(self=a, node=b), node=c)
    self.assertEqual(left, right)

@given(a=add_function_entity_operands, b=add_function_entity_operands)
def test_commutative_binary_operation_ModuleParser_add_function_entity(self, a, b) -&gt; None:
    left = hypot_test_gen.ModuleParser.add_function_entity(self=a, node=b)
    right = hypot_test_gen.ModuleParser.add_function_entity(self=b, node=a)
    self.assertEqual(left, right)

@given(a=add_function_entity_operands)
def test_identity_binary_operation_ModuleParser_add_function_entity(self, a) -&gt; None:
    identity = &#39;&lt;ast.FunctionDef object at 0x125566c20&gt;&#39;
    self.assertEqual(a, hypot_test_gen.ModuleParser.add_function_entity(self=a, node=identity))
    self.assertEqual(a, hypot_test_gen.ModuleParser.add_function_entity(self=identity, node=a))
</code></pre></div>
<h1 id="-test_testgenerator_create_variant_errorspy-">----- test_TestGenerator_create_variant_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorcreate_Variant(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), variant_type=st.text(), cmd=st.text())
def test_fuzz_TestGenerator_create_variant(self, variant_type: str, cmd: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.create_variant(self=self, variant_type=variant_type, cmd=cmd)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_run_hypothesis_write_basicpy-">----- test_TestGenerator_run_hypothesis_write_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorrun_Hypothesis_Write(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), command=st.text())
def test_fuzz_TestGenerator_run_hypothesis_write(self, command: str) -&gt; None:
    hypot_test_gen.TestGenerator.run_hypothesis_write(self=self, command=command)
</code></pre></div>
<h1 id="-test_moduleparser_determine_instance_method_basicpy-">----- test_ModuleParser_determine_instance_method_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, strategies as st</p>
<p>class TestFuzzModuleparserdetermine_Instance_Method(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_ModuleParser_determine_instance_method(self, node: ast.FunctionDef) -&gt; None:
    hypot_test_gen.ModuleParser.determine_instance_method(self=self, node=node)
</code></pre></div>
<h1 id="-test_testgenerator_display_module_info_basicpy-">----- test_TestGenerator_display_module_info_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratordisplay_Module_Info(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), module_path=st.text(), entities=st.lists(st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text()))))
def test_fuzz_TestGenerator_display_module_info(self, module_path: str, entities: typing.List[hypot_test_gen.TestableEntity]) -&gt; None:
    hypot_test_gen.TestGenerator.display_module_info(self=self, module_path=module_path, entities=entities)
</code></pre></div>
<h1 id="-test_moduleparser_process_class_contents_basicpy-">----- test_ModuleParser_process_class_contents_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import ClassDef
from hypothesis import given, strategies as st</p>
<p>class TestFuzzModuleparserprocess_Class_Contents(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(ClassDef))
def test_fuzz_ModuleParser_process_class_contents(self, node: ast.ClassDef) -&gt; None:
    hypot_test_gen.ModuleParser.process_class_contents(self=self, node=node)
</code></pre></div>
<h1 id="-test_testgenerator_parse_ast_basicpy-">----- test_TestGenerator_parse_ast_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorparse_Ast(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), content=st.text())
def test_fuzz_TestGenerator_parse_ast(self, content: str) -&gt; None:
    hypot_test_gen.TestGenerator.parse_ast(self=self, content=content)
</code></pre></div>
<h1 id="-test_testgenerator_process_entities_errorspy-">----- test_TestGenerator_process_entities_errors.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorprocess_Entities(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entities=st.lists(st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text()))), total_variants=st.integers(), module_path=st.text())
def test_fuzz_TestGenerator_process_entities(self, entities: typing.List[hypot_test_gen.TestableEntity], total_variants: int, module_path: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.process_entities(self=self, entities=entities, total_variants=total_variants, module_path=module_path)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_store_class_bases_errorspy-">----- test_ModuleParser_store_class_bases_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import ClassDef
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzModuleparserstore_Class_Bases(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(ClassDef))
def test_fuzz_ModuleParser_store_class_bases(self, node: ast.ClassDef) -&gt; None:
    try:
        hypot_test_gen.ModuleParser.store_class_bases(self=self, node=node)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_run_hypothesis_write_errorspy-">----- test_TestGenerator_run_hypothesis_write_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorrun_Hypothesis_Write(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), command=st.text())
def test_fuzz_TestGenerator_run_hypothesis_write(self, command: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.run_hypothesis_write(self=self, command=command)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_wrap_with_prompt_basicpy-">----- test_TestGenerator_wrap_with_prompt_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorwrap_With_Prompt(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), combined_test_code=st.text(), original_source_code=st.text())
def test_fuzz_TestGenerator_wrap_with_prompt(self, combined_test_code: str, original_source_code: str) -&gt; None:
    hypot_test_gen.TestGenerator.wrap_with_prompt(self=self, combined_test_code=combined_test_code, original_source_code=original_source_code)
</code></pre></div>
<h1 id="-test_testgenerator_pre_run_cleanup_errorspy-">----- test_TestGenerator_pre_run_cleanup_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorpre_Run_Cleanup(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_pre_run_cleanup(self) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.pre_run_cleanup(self=self)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testableentity_basicpy-">----- test_TestableEntity_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestableentity(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(name=st.text(), module_path=st.text(), entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), parent_class=st.one_of(st.none(), st.text()))
def test_fuzz_TestableEntity(self, name: str, module_path: str, entity_type, parent_class: typing.Optional[str]) -&gt; None:
    hypot_test_gen.TestableEntity(name=name, module_path=module_path, entity_type=entity_type, parent_class=parent_class)
</code></pre></div>
<h1 id="-test_testgenerator_write_and_verify_output_basicpy-">----- test_TestGenerator_write_and_verify_output_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorwrite_And_Verify_Output(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), output_file=st.from_type(pathlib.Path), content=st.text())
def test_fuzz_TestGenerator_write_and_verify_output(self, output_file: pathlib.Path, content: str) -&gt; None:
    hypot_test_gen.TestGenerator.write_and_verify_output(self=self, output_file=output_file, content=content)
</code></pre></div>
<h1 id="-test_fix_duplicate_self_basicpy-">----- test_fix_duplicate_self_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzFix_Duplicate_Self(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(test_content=st.text())
def test_fuzz_fix_duplicate_self(self, test_content: str) -&gt; None:
    hypot_test_gen.fix_duplicate_self(test_content=test_content)
</code></pre></div>
<h1 id="-test_testgenerator_is_known_error_errorspy-">----- test_TestGenerator_is_known_error_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratoris_Known_Error(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), stderr=st.text())
def test_fuzz_TestGenerator_is_known_error(self, stderr: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.is_known_error(self=self, stderr=stderr)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_process_class_contents_errorspy-">----- test_ModuleParser_process_class_contents_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import ClassDef
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzModuleparserprocess_Class_Contents(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(ClassDef))
def test_fuzz_ModuleParser_process_class_contents(self, node: ast.ClassDef) -&gt; None:
    try:
        hypot_test_gen.ModuleParser.process_class_contents(self=self, node=node)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_generate_all_tests_errorspy-">----- test_TestGenerator_generate_all_tests_errors.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, reject, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorgenerate_All_Tests(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), file_path=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator_generate_all_tests(self, file_path: pathlib.Path) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.generate_all_tests(self=self, file_path=file_path)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_post_process_test_content_errorspy-">----- test_TestGenerator_post_process_test_content_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorpost_Process_Test_Content(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), content=st.text())
def test_fuzz_TestGenerator_post_process_test_content(self, content: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.post_process_test_content(self=self, content=content)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_add_class_entity_binary-oppy-">----- test_ModuleParser_add_class_entity_binary-op.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestBinaryOperationadd_class_entity(unittest.TestCase):
    add_class_entity_operands = st.builds(ClassDef)</p>
<div class="highlight"><pre><span></span><code>@given(a=add_class_entity_operands, b=add_class_entity_operands, c=add_class_entity_operands)
def test_associative_binary_operation_ModuleParser_add_class_entity(self, a, b, c) -&gt; None:
    left = hypot_test_gen.ModuleParser.add_class_entity(self=a, node=hypot_test_gen.ModuleParser.add_class_entity(self=b, node=c))
    right = hypot_test_gen.ModuleParser.add_class_entity(self=hypot_test_gen.ModuleParser.add_class_entity(self=a, node=b), node=c)
    self.assertEqual(left, right)

@given(a=add_class_entity_operands, b=add_class_entity_operands)
def test_commutative_binary_operation_ModuleParser_add_class_entity(self, a, b) -&gt; None:
    left = hypot_test_gen.ModuleParser.add_class_entity(self=a, node=b)
    right = hypot_test_gen.ModuleParser.add_class_entity(self=b, node=a)
    self.assertEqual(left, right)

@given(a=add_class_entity_operands)
def test_identity_binary_operation_ModuleParser_add_class_entity(self, a) -&gt; None:
    identity = &#39;&lt;ast.ClassDef object at 0x125deec50&gt;&#39;
    self.assertEqual(a, hypot_test_gen.ModuleParser.add_class_entity(self=a, node=identity))
    self.assertEqual(a, hypot_test_gen.ModuleParser.add_class_entity(self=identity, node=a))
</code></pre></div>
<h1 id="-test_testgenerator_verify_output_dir_errorspy-">----- test_TestGenerator_verify_output_dir_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorverify_Output_Dir(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_verify_output_dir(self) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.verify_output_dir(self=self)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_handle_generated_output_basicpy-">----- test_TestGenerator_handle_generated_output_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorhandle_Generated_Output(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())), variant=st.dictionaries(keys=st.text(), values=st.text()), output=st.text())
def test_fuzz_TestGenerator_handle_generated_output(self, entity: hypot_test_gen.TestableEntity, variant: typing.Dict[str, str], output: str) -&gt; None:
    hypot_test_gen.TestGenerator.handle_generated_output(self=self, entity=entity, variant=variant, output=output)
</code></pre></div>
<h1 id="-test_moduleparser_process_method_idempotentpy-">----- test_ModuleParser_process_method_idempotent.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, strategies as st</p>
<p>class TestIdempotentModuleparserprocess_Method(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_idempotent_ModuleParser_process_method(self, node: ast.FunctionDef) -&gt; None:
    result = hypot_test_gen.ModuleParser.process_method(self=self, node=node)
    repeat = hypot_test_gen.ModuleParser.process_method(self=result, node=node)
    self.assertEqual(result, repeat)
</code></pre></div>
<h1 id="-test_testgenerator_process_hypothesis_result_basicpy-">----- test_TestGenerator_process_hypothesis_result_basic.py -----</h1>
<p>import hypot_test_gen
import subprocess
import unittest
from hypothesis import given, strategies as st
from subprocess import CompletedProcess</p>
<p>class TestFuzzTestgeneratorprocess_Hypothesis_Result(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), result=st.from_type(subprocess.CompletedProcess))
def test_fuzz_TestGenerator_process_hypothesis_result(self, result: subprocess.CompletedProcess) -&gt; None:
    hypot_test_gen.TestGenerator.process_hypothesis_result(self=self, result=result)
</code></pre></div>
<h1 id="-test_testgenerator_generate_method_variants_basicpy-">----- test_TestGenerator_generate_method_variants_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorgenerate_Method_Variants(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())))
def test_fuzz_TestGenerator_generate_method_variants(self, entity: hypot_test_gen.TestableEntity) -&gt; None:
    hypot_test_gen.TestGenerator.generate_method_variants(self=self, entity=entity)
</code></pre></div>
<h1 id="-test_testgenerator_post_process_test_content_idempotentpy-">----- test_TestGenerator_post_process_test_content_idempotent.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestIdempotentTestgeneratorpost_Process_Test_Content(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), content=st.text())
def test_idempotent_TestGenerator_post_process_test_content(self, content: str) -&gt; None:
    result = hypot_test_gen.TestGenerator.post_process_test_content(self=self, content=content)
    repeat = hypot_test_gen.TestGenerator.post_process_test_content(self=result, content=content)
    self.assertEqual(result, repeat)
</code></pre></div>
<h1 id="-test_add_to_sys_path_basicpy-">----- test_add_to_sys_path_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzAdd_To_Sys_Path(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(path=st.text(), description=st.text())
def test_fuzz_add_to_sys_path(self, path: str, description: str) -&gt; None:
    hypot_test_gen.add_to_sys_path(path=path, description=description)
</code></pre></div>
<h1 id="-test_testgenerator_generate_method_variants_errorspy-">----- test_TestGenerator_generate_method_variants_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorgenerate_Method_Variants(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())))
def test_fuzz_TestGenerator_generate_method_variants(self, entity: hypot_test_gen.TestableEntity) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.generate_method_variants(self=self, entity=entity)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_parse_ast_errorspy-">----- test_TestGenerator_parse_ast_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorparse_Ast(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), content=st.text())
def test_fuzz_TestGenerator_parse_ast(self, content: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.parse_ast(self=self, content=content)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_store_class_bases_basicpy-">----- test_ModuleParser_store_class_bases_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import ClassDef
from hypothesis import given, strategies as st</p>
<p>class TestFuzzModuleparserstore_Class_Bases(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(ClassDef))
def test_fuzz_ModuleParser_store_class_bases(self, node: ast.ClassDef) -&gt; None:
    hypot_test_gen.ModuleParser.store_class_bases(self=self, node=node)
</code></pre></div>
<h1 id="-test_testgenerator_log_entities_summary_basicpy-">----- test_TestGenerator_log_entities_summary_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorlog_Entities_Summary(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entities=st.lists(st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text()))))
def test_fuzz_TestGenerator_log_entities_summary(self, entities: typing.List[hypot_test_gen.TestableEntity]) -&gt; None:
    hypot_test_gen.TestGenerator.log_entities_summary(self=self, entities=entities)
</code></pre></div>
<h1 id="-test_testgenerator_handle_failed_attempt_errorspy-">----- test_TestGenerator_handle_failed_attempt_errors.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorhandle_Failed_Attempt(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())), variant=st.dictionaries(keys=st.text(), values=st.text()), attempt=st.integers())
def test_fuzz_TestGenerator_handle_failed_attempt(self, entity: hypot_test_gen.TestableEntity, variant: typing.Dict[str, str], attempt: int) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.handle_failed_attempt(self=self, entity=entity, variant=variant, attempt=attempt)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_add_to_sys_path_binary-oppy-">----- test_add_to_sys_path_binary-op.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestBinaryOperationadd_to_sys_path(unittest.TestCase):
    add_to_sys_path_operands = st.text()</p>
<div class="highlight"><pre><span></span><code>@given(a=add_to_sys_path_operands, b=add_to_sys_path_operands, c=add_to_sys_path_operands)
def test_associative_binary_operation_add_to_sys_path(self, a, b, c) -&gt; None:
    left = hypot_test_gen.add_to_sys_path(path=a, description=hypot_test_gen.add_to_sys_path(path=b, description=c))
    right = hypot_test_gen.add_to_sys_path(path=hypot_test_gen.add_to_sys_path(path=a, description=b), description=c)
    self.assertEqual(left, right)

@given(a=add_to_sys_path_operands, b=add_to_sys_path_operands)
def test_commutative_binary_operation_add_to_sys_path(self, a, b) -&gt; None:
    left = hypot_test_gen.add_to_sys_path(path=a, description=b)
    right = hypot_test_gen.add_to_sys_path(path=b, description=a)
    self.assertEqual(left, right)

@given(a=add_to_sys_path_operands)
def test_identity_binary_operation_add_to_sys_path(self, a) -&gt; None:
    identity = &#39;&#39;
    self.assertEqual(a, hypot_test_gen.add_to_sys_path(path=a, description=identity))
    self.assertEqual(a, hypot_test_gen.add_to_sys_path(path=identity, description=a))
</code></pre></div>
<h1 id="-test_testgenerator_pre_run_cleanup_basicpy-">----- test_TestGenerator_pre_run_cleanup_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorpre_Run_Cleanup(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_pre_run_cleanup(self) -&gt; None:
    hypot_test_gen.TestGenerator.pre_run_cleanup(self=self)
</code></pre></div>
<h1 id="-test_testgenerator_populate_entities_errorspy-">----- test_TestGenerator_populate_entities_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypot_test_gen import ModuleParser
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorpopulate_Entities(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), parser=st.builds(ModuleParser), module_path=st.text())
def test_fuzz_TestGenerator_populate_entities(self, parser: hypot_test_gen.ModuleParser, module_path: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.populate_entities(self=self, parser=parser, module_path=module_path)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_log_environment_basicpy-">----- test_TestGenerator_log_environment_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorlog_Environment(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_log_environment(self) -&gt; None:
    hypot_test_gen.TestGenerator.log_environment(self=self)
</code></pre></div>
<h1 id="-test_testgenerator_attempt_test_generation_errorspy-">----- test_TestGenerator_attempt_test_generation_errors.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorattempt_Test_Generation(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())), variant=st.dictionaries(keys=st.text(), values=st.text()), attempt=st.integers())
def test_fuzz_TestGenerator_attempt_test_generation(self, entity: hypot_test_gen.TestableEntity, variant: typing.Dict[str, str], attempt: int) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.attempt_test_generation(self=self, entity=entity, variant=variant, attempt=attempt)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<p>FULL SRC CODE: import ast
import logging
import os
import subprocess
import sys
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union, Literal, Any</p>
<p>import snoop  # type: ignore</p>
<h1 id="removed-unused-from-hypothesis-import-strategies-as-st">Removed unused: from hypothesis import strategies as st</h1>
<p>import importlib.util  # For dynamic imports</p>
<h1 id="set-up-logging-with-file-and-console-output">Set up logging with file and console output</h1>
<p>log_file = "test_generator_debug.log"
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.FileHandler(log_file), logging.StreamHandler()],
)
logger = logging.getLogger(<strong>name</strong>)</p>
<h1 id="well-assume-the-prompt_templatemd-is-in-the-same-directory-as-this-script">We'll assume the prompt_template.md is in the same directory as this script</h1>
<p>PROMPT_TEMPLATE_FILE = Path(<strong>file</strong>).parent / "prompt_template.md"</p>
<p>def load_text_prompt_template() -&gt; str:
    """
    Load the text prompt template from the prompt_template.md file.
    """
    try:
        return PROMPT_TEMPLATE_FILE.read_text(encoding="utf-8")
    except FileNotFoundError:
        logger.error("prompt_template.md not found. Please ensure it is in the same directory.")
        return ""</p>
<h1 id="configure-snoop-to-write-to-a-separate-debug-log">Configure snoop to write to a separate debug log</h1>
<p>snoop.install(out=Path("snoop_debug.log"))</p>
<p>def fix_leading_zeros(test_code: str) -&gt; str:
    """
    Replace decimal integers with leading zeros (except a standalone "0") with their corrected form.
    For example, "007" becomes "7" and "-0123" becomes "-123".
    """
    import re
    # Use a regex with negative lookbehind and lookahead to match numbers that start with one or more zeros.
    # The pattern (?&lt;!\d)(-?)0+(\d+)(?!\d) ensures that a minus sign is captured if present,
    # and that only isolated numbers are matched.
    fixed_code = re.sub(r'(?&lt;!\d)(-?)0+(\d+)(?!\d)', lambda m: m.group(1) + str(int(m.group(2))), test_code)
    return fixed_code</p>
<p>def remove_logger_lines(text: str) -&gt; str:
    """
    Remove extraneous logging lines from the generated test content.
    This function filters out:
      - Lines starting with a bracketed or non-bracketed timestamp (e.g. "[2025-3-27 14:55:48,330] ..." or "2025-03-27 14:55:48,330 - ...").
      - Lines containing known noisy substrings such as 'real_accelerator.py:' or 'Setting ds_accelerator to'.
    """
    import re
    lines = text.splitlines()
    filtered = []
    timestamp_pattern = re.compile(r'^[?\d{4}-\d{1,2}-\d{1,2}')
    for line in lines:
        # Skip lines matching a leading timestamp
        if timestamp_pattern.match(line):
            continue
        # Skip lines containing known noisy substrings
        if 'real_accelerator.py:' in line or 'Setting ds_accelerator to' in line:
            continue
        filtered.append(line)
    return "\n".join(filtered).strip()</p>
<p>@dataclass
class TestableEntity:
    """Represents a class, method, or function that can be tested"""
    name: str
    module_path: str
    entity_type: Literal['class', 'method', 'function', 'instance_method']  # More restrictive type
    parent_class: Optional[str] = None</p>
<p>def fix_pythonpath(file_path: Path) -&gt; None:
    """Ensure the module being tested is in Python's path"""
    parent_dir = str(file_path.parent.absolute())
    add_to_sys_path(parent_dir, "parent directory")</p>
<div class="highlight"><pre><span></span><code>if &quot;src&quot; in file_path.parts:
    src_path = construct_src_path(file_path)
    add_to_sys_path(src_path, &quot;src directory&quot;)
</code></pre></div>
<p>def add_to_sys_path(path: str, description: str) -&gt; None:
    """Helper function to add a path to sys.path if not already present"""
    if path not in sys.path:
        sys.path.insert(0, path)
        logger.debug(f"Added {description} to sys.path: {path}")</p>
<p>def construct_src_path(file_path: Path) -&gt; str:
    """Construct the src path from the file path"""
    src_index = file_path.parts.index("src")
    src_path = str(Path(*file_path.parts[: src_index + 1]).absolute())
    return src_path</p>
<p>class ModuleParser(ast.NodeVisitor):
    """AST-based parser for Python modules"""</p>
<div class="highlight"><pre><span></span><code>def __init__(self):
    self.entities: List[TestableEntity] = []
    self.current_class: Optional[str] = None
    self.class_bases: Dict[str, List[str]] = {}

def visit_ClassDef(self, node: ast.ClassDef) -&gt; None:
    if node.name.startswith(&quot;_&quot;):
        return
    self.store_class_bases(node)
    self.add_class_entity(node)
    self.process_class_contents(node)

def store_class_bases(self, node: ast.ClassDef) -&gt; None:
    &quot;&quot;&quot;Store base classes for inheritance checking&quot;&quot;&quot;
    bases = []
    for base in node.bases:
        base_name = self.get_base_name(base)
        if base_name:
            bases.append(base_name)
    self.class_bases[node.name] = bases
    logger.debug(f&quot;Stored bases for class {node.name}: {bases}&quot;)

def get_base_name(self, base: ast.AST) -&gt; Optional[str]:
    &quot;&quot;&quot;Retrieve the base class name from the AST node&quot;&quot;&quot;
    if isinstance(base, ast.Name):
        return base.id
    elif isinstance(base, ast.Attribute):
        if isinstance(base.value, ast.Name):
            return f&quot;{base.value.id}.{base.attr}&quot;
    return None

def add_class_entity(self, node: ast.ClassDef) -&gt; None:
    &quot;&quot;&quot;Add the class itself to entities&quot;&quot;&quot;
    self.entities.append(TestableEntity(node.name, &quot;&quot;, &quot;class&quot;))
    logger.debug(f&quot;Added class entity: {node.name}&quot;)

def process_class_contents(self, node: ast.ClassDef) -&gt; None:
    &quot;&quot;&quot;Process the contents of the class&quot;&quot;&quot;
    old_class = self.current_class
    self.current_class = node.name
    self.generic_visit(node)
    self.current_class = old_class
    logger.debug(f&quot;Processed contents of class {node.name}&quot;)

def visit_FunctionDef(self, node: ast.FunctionDef) -&gt; None:
    if node.name.startswith(&quot;_&quot;):
        return
    if self.current_class:
        self.process_method(node)
    else:
        self.add_function_entity(node)

def process_method(self, node: ast.FunctionDef) -&gt; None:
    &quot;&quot;&quot;Process a method within a class&quot;&quot;&quot;
    if self.should_skip_method(node):
        return

    is_instance_method = self.determine_instance_method(node)
    entity_type = &quot;instance_method&quot; if is_instance_method else &quot;method&quot;

    # The method path should include the class
    method_name = f&quot;{self.current_class}.{node.name}&quot; if self.current_class else node.name

    self.entities.append(
        TestableEntity(
            name=node.name,
            module_path=&quot;&quot;,
            entity_type=entity_type,
            parent_class=self.current_class,
        )
    )
    logger.debug(
        f&quot;Added {&#39;instance_method&#39; if is_instance_method else &#39;method&#39;} entity: {method_name}&quot;
    )

def determine_instance_method(self, node: ast.FunctionDef) -&gt; bool:
    &quot;&quot;&quot;Determine if the method is an instance method&quot;&quot;&quot;
    for decorator in node.decorator_list:
        if isinstance(decorator, ast.Name) and decorator.id in {&quot;classmethod&quot;, &quot;staticmethod&quot;}:
            return False
    return True

def should_skip_method(self, node: ast.FunctionDef) -&gt; bool:
    &quot;&quot;&quot;Determine if the method should be skipped based on inheritance or naming&quot;&quot;&quot;
    current_bases = self.class_bases.get(self.current_class, [])
    if any(base in {&quot;NodeVisitor&quot;, &quot;ast.NodeVisitor&quot;} for base in current_bases):
        if node.name.startswith(&quot;visit_&quot;):
            logger.debug(f&quot;Skipping inherited visit method: {node.name}&quot;)
            return True
    if node.name in {&quot;__init__&quot;, &quot;__str__&quot;, &quot;__repr__&quot;, &quot;property&quot;}:
        logger.debug(f&quot;Skipping magic or property method: {node.name}&quot;)
        return True
    return False

def add_function_entity(self, node: ast.FunctionDef) -&gt; None:
    &quot;&quot;&quot;Add a standalone function to entities&quot;&quot;&quot;
    self.entities.append(TestableEntity(node.name, &quot;&quot;, &quot;function&quot;))
    logger.debug(f&quot;Added function entity: {node.name}&quot;)
</code></pre></div>
<p>def debug_command_output(cmd: str, stdout: str, stderr: str, returncode: int) -&gt; None:
    """Helper function to debug command execution"""
    logger.debug("Command execution details:")
    logger.debug(f"Command: {cmd}")
    logger.debug(f"Return code: {returncode}")
    logger.debug(f"stdout length: {len(stdout)}")
    logger.debug(f"stderr length: {len(stderr)}")
    logger.debug("First 1000 chars of stdout:")
    logger.debug(stdout[:1000])
    logger.debug("First 1000 chars of stderr:")
    logger.debug(stderr[:1000])</p>
<p>class TestFixer(ast.NodeTransformer):
    """AST transformer to fix duplicate self parameters"""</p>
<div class="highlight"><pre><span></span><code>def visit_FunctionDef(self, node: ast.FunctionDef) -&gt; ast.FunctionDef:
    seen_self = False
    new_args = []

    for arg in node.args.args:
        if arg.arg == &#39;self&#39;:
            if not seen_self:
                seen_self = True
                new_args.append(arg)
        else:
            new_args.append(arg)

    node.args.args = new_args
    return node
</code></pre></div>
<p>def fix_duplicate_self(test_content: str) -&gt; Optional[str]:
    """
    Fix duplicate self parameters in test content.</p>
<div class="highlight"><pre><span></span><code>Args:
    test_content: String containing the test code

Returns:
    Fixed test code string, or None if parsing fails
&quot;&quot;&quot;
try:
    tree = ast.parse(test_content)

    fixer = TestFixer()
    fixed_tree = fixer.visit(tree)

    try:
        return ast.unparse(fixed_tree)
    except AttributeError:
        import astunparse
        return astunparse.unparse(fixed_tree)

except Exception as e:
    print(f&quot;Error fixing test content: {e}&quot;)
    return None
</code></pre></div>
<p>class TestGenerator:
    """Manages generation of Hypothesis tests for Python modules"""
    def wrap_with_prompt(self, combined_test_code: str, original_source_code: str) -&gt; str:
        """
        Wrap the combined test code and original source code in the custom text prompt
        read from 'prompt_template.md'.
        """
        prompt_template = load_text_prompt_template()
        return prompt_template.format(
            TEST_CODE=combined_test_code,
            FULL_SRC_CODE=original_source_code
        )</p>
<div class="highlight"><pre><span></span><code>def pre_run_cleanup(self) -&gt; None:
    &quot;&quot;&quot;
    Remove any leftover combined test files (matching &#39;test_hyp_*.py&#39;) from previous runs.
    This ensures we don&#39;t mix old combined files with new runs.
    &quot;&quot;&quot;
    leftover_files = list(self.output_dir.glob(&quot;test_hyp_*.py&quot;))
    for leftover in leftover_files:
        try:
            leftover.unlink()
            logger.debug(f&quot;Removed leftover combined file: {leftover.name}&quot;)
        except Exception as e:
            logger.error(f&quot;Failed to delete leftover file {leftover.name}: {e}&quot;)

def __init__(self, output_dir: Path = Path(&quot;generated_tests&quot;)):
    self.output_dir = output_dir
    self.output_dir.mkdir(exist_ok=True)
    self.verify_output_dir()

def verify_output_dir(self) -&gt; None:
    &quot;&quot;&quot;Verify that the output directory exists and is writable&quot;&quot;&quot;
    logger.debug(f&quot;Test generator initialized with output dir: {self.output_dir}&quot;)
    logger.debug(f&quot;Output dir exists: {self.output_dir.exists()}&quot;)
    logger.debug(f&quot;Output dir is writable: {os.access(self.output_dir, os.W_OK)}&quot;)

def run_hypothesis_write(self, command: str) -&gt; Optional[str]:
    &quot;&quot;&quot;Execute hypothesis write command and return output if successful&quot;&quot;&quot;
    full_cmd = f&quot;hypothesis write {command}&quot;
    logger.debug(f&quot;Executing hypothesis command: {full_cmd}&quot;)

    try:
        self.log_environment()
        env = self.prepare_environment()

        result = subprocess.run(
            full_cmd, shell=True, capture_output=True, text=True, env=env
        )

        debug_command_output(
            full_cmd, result.stdout, result.stderr, result.returncode
        )

        return self.process_hypothesis_result(result)

    except Exception as e:
        logger.error(f&quot;Error running hypothesis: {e}&quot;, exc_info=True)
        return None

def log_environment(self) -&gt; None:
    &quot;&quot;&quot;Log the current environment settings&quot;&quot;&quot;
    logger.debug(f&quot;PYTHONPATH before modification: {os.getenv(&#39;PYTHONPATH&#39;)}&quot;)
    logger.debug(f&quot;sys.path: {sys.path}&quot;)
    logger.debug(f&quot;Current working directory: {os.getcwd()}&quot;)

def prepare_environment(self) -&gt; Dict[str, str]:
    &quot;&quot;&quot;Prepare the environment variables for subprocess&quot;&quot;&quot;
    env = os.environ.copy()
    env[&quot;PYTHONPATH&quot;] = &quot;:&quot;.join(sys.path)
    env.setdefault(&quot;PYTHONIOENCODING&quot;, &quot;utf-8&quot;)
    return env

def process_hypothesis_result(self, result: subprocess.CompletedProcess) -&gt; Optional[str]:
    &quot;&quot;&quot;Process the result of the hypothesis command&quot;&quot;&quot;
    if result.returncode == 0 and result.stdout:
        content = result.stdout.strip()

        # Remove extraneous logging lines first
        content = remove_logger_lines(content)

        if not content or len(content) &lt; 50:
            logger.warning(&quot;Hypothesis generated insufficient content&quot;)
            return None

        # Process and fix the test content using post_process_test_content
        fixed_content = self.post_process_test_content(content)
        if fixed_content is None:
            logger.warning(&quot;Failed to process test content&quot;)
            return None

        logger.info(&quot;Successfully generated and processed test content&quot;)
        return fixed_content

    if result.stderr and not self.is_known_error(result.stderr):
        logger.warning(f&quot;Command failed: {result.stderr}&quot;)
    return None

def post_process_test_content(self, content: str) -&gt; Optional[str]:
    &quot;&quot;&quot;Post-process generated test content&quot;&quot;&quot;
    try:
        # Also remove extraneous logger lines (defensive)
        content = remove_logger_lines(content)

        # First, fix any leading zeros in integer literals
        content = fix_leading_zeros(content)
        # Then, fix duplicate self parameters
        fixed_content = fix_duplicate_self(content)
        if fixed_content is None:
            logger.warning(&quot;Failed to fix duplicate self parameters.&quot;)
            return content
        return fixed_content
    except Exception as e:
        logger.error(f&quot;Error processing test content: {e}&quot;, exc_info=True)
        return None

def is_known_error(self, stderr: str) -&gt; bool:
    &quot;&quot;&quot;Check if the stderr contains known non-critical errors&quot;&quot;&quot;
    known_errors = [
        &quot;InvalidArgument: Got non-callable&quot;,
        &quot;Could not resolve&quot;,
        &quot;but it doesn&#39;t have a&quot;,
    ]
    return any(msg in stderr for msg in known_errors)

def try_generate_test(
    self, entity: TestableEntity, variant: Dict[str, str], max_retries: int = 3
) -&gt; bool:
    &quot;&quot;&quot;Attempt to generate a specific test variant with retries&quot;&quot;&quot;
    for attempt in range(1, max_retries + 1):
        logger.debug(
            f&quot;Attempt {attempt} for {variant[&#39;type&#39;]} test on {entity.name}&quot;
        )
        output = self.attempt_test_generation(entity, variant, attempt)
        if output:
            return True
    return False

def attempt_test_generation(
    self, entity: TestableEntity, variant: Dict[str, str], attempt: int
) -&gt; Optional[bool]:
    &quot;&quot;&quot;Attempt a single test generation&quot;&quot;&quot;
    output = self.run_hypothesis_write(variant[&quot;cmd&quot;])
    if output:
        return self.handle_generated_output(entity, variant, output)
    else:
        return self.handle_failed_attempt(entity, variant, attempt)

def handle_generated_output(
    self, entity: TestableEntity, variant: Dict[str, str], output: str
) -&gt; bool:
    &quot;&quot;&quot;Handle the output from a successful hypothesis generation&quot;&quot;&quot;
    name_prefix = (
        f&quot;{entity.parent_class}_{entity.name}&quot;
        if entity.parent_class
        else entity.name
    )
    output_file = self.output_dir / f&quot;test_{name_prefix}_{variant[&#39;type&#39;]}.py&quot;

    try:
        self.write_and_verify_output(output_file, output)
        logger.info(f&quot;Successfully generated test at {output_file}&quot;)
        print(f&quot;Generated {variant[&#39;type&#39;]} test: {output_file}&quot;)
        return True
    except Exception as e:
        logger.error(f&quot;Error writing test file: {e}&quot;, exc_info=True)
        return False

def write_and_verify_output(self, output_file: Path, content: str) -&gt; None:
    &quot;&quot;&quot;Write the test content to a file and verify its integrity&quot;&quot;&quot;
    logger.debug(&quot;Test content details:&quot;)
    logger.debug(f&quot;Content length: {len(content)}&quot;)
    logger.debug(f&quot;Content preview:\n{content[:1000]}&quot;)
    logger.debug(f&quot;Writing to file: {output_file}&quot;)

    output_file.write_text(content)

    written_content = output_file.read_text()
    if not written_content:
        logger.error(f&quot;File {output_file} is empty after writing!&quot;)
        raise ValueError(f&quot;Empty file: {output_file}&quot;)

    if written_content != content:
        logger.error(&quot;Written content doesn&#39;t match original content!&quot;)
        logger.debug(f&quot;Original length: {len(content)}&quot;)
        logger.debug(f&quot;Written length: {len(written_content)}&quot;)
        raise ValueError(&quot;Content mismatch after writing&quot;)

    logger.debug(f&quot;Final file size: {output_file.stat().st_size} bytes&quot;)

def handle_failed_attempt(
    self, entity: TestableEntity, variant: Dict[str, str], attempt: int
) -&gt; Optional[bool]:
    &quot;&quot;&quot;Handle a failed test generation attempt&quot;&quot;&quot;
    if attempt &lt; 3:
        logger.warning(f&quot;Attempt {attempt} failed, retrying...&quot;)
        time.sleep(1)
    else:
        logger.error(f&quot;All attempts failed for {entity.name}&quot;)
    return None

def get_module_contents(self, file_path: Path) -&gt; Tuple[str, List[TestableEntity]]:
    &quot;&quot;&quot;Extract module path and testable entities using AST parsing&quot;&quot;&quot;
    logger.debug(f&quot;Reading file: {file_path}&quot;)
    try:
        module_path = self.construct_module_path(file_path)
        content = file_path.read_text()
        parser = self.parse_ast(content)
        imports = self.extract_imports(content)

        entities = self.populate_entities(parser, module_path)
        self.log_entities_summary(entities)
        return module_path, entities

    except Exception as e:
        logger.error(f&quot;Error parsing module contents: {e}&quot;, exc_info=True)
        raise

def construct_module_path(self, file_path: Path) -&gt; str:
    &quot;&quot;&quot;Construct the module path from the file path&quot;&quot;&quot;
    parts = file_path.parts
    if &quot;src&quot; in parts:
        src_index = parts.index(&quot;src&quot;)
        module_parts = list(parts[src_index + 1 :])
    else:
        module_parts = [file_path.stem]
    module_path = &quot;.&quot;.join([p.replace(&quot;.py&quot;, &quot;&quot;) for p in module_parts])
    logger.debug(f&quot;Constructed module path: {module_path}&quot;)
    return module_path

def parse_ast(self, content: str) -&gt; ModuleParser:
    &quot;&quot;&quot;Parse the AST of the given content&quot;&quot;&quot;
    tree = ast.parse(content)
    parser = ModuleParser()
    parser.visit(tree)
    return parser

def extract_imports(self, content: str) -&gt; set:
    &quot;&quot;&quot;Extract import statements from the content&quot;&quot;&quot;
    tree = ast.parse(content)
    imports = set()
    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            for name in node.names:
                imports.add(name.name)
        elif isinstance(node, ast.ImportFrom):
            if node.module:
                imports.add(node.module)
    logger.debug(f&quot;Found imports: {imports}&quot;)
    return imports

def populate_entities(self, parser: ModuleParser, module_path: str) -&gt; List[TestableEntity]:
    &quot;&quot;&quot;Populate entities with correct module paths&quot;&quot;&quot;
    entities = []
    for entity in parser.entities:
        entity.module_path = module_path
        entities.append(entity)
    return entities

def log_entities_summary(self, entities: List[TestableEntity]) -&gt; None:
    &quot;&quot;&quot;Log a summary of found entities&quot;&quot;&quot;
    classes = sum(1 for e in entities if e.entity_type == &quot;class&quot;)
    methods = sum(
        1 for e in entities if e.entity_type in {&quot;method&quot;, &quot;instance_method&quot;}
    )
    functions = sum(1 for e in entities if e.entity_type == &quot;function&quot;)
    logger.info(
        f&quot;Found {classes} classes, {methods} methods, and {functions} functions&quot;
    )

def generate_all_tests(self, file_path: Path) -&gt; None:
    &quot;&quot;&quot;Generate all possible test variants for a Python file&quot;&quot;&quot;
    logger.info(f&quot;Generating tests for file: {file_path}&quot;)
    try:
        fix_pythonpath(file_path)
        module_path, entities = self.get_module_contents(file_path)
        self.display_module_info(module_path, entities)
        total_variants = sum(len(self.generate_test_variants(e)) for e in entities)
        self.process_entities(entities, total_variants, module_path)
        print()
        self.combine_and_cleanup_tests(file_path)
    except Exception:
        logger.error(&quot;Test generation failed&quot;, exc_info=True)
        raise

def display_module_info(self, module_path: str, entities: List[TestableEntity]) -&gt; None:
    &quot;&quot;&quot;Display information about the module and its entities&quot;&quot;&quot;
    print(f&quot;\nProcessing module: {module_path}&quot;)
    print(
        f&quot;Found {len([e for e in entities if e.entity_type == &#39;class&#39;])} classes, &quot;
        f&quot;{len([e for e in entities if e.entity_type in {&#39;method&#39;, &#39;instance_method&#39;}])} methods, and &quot;
        f&quot;{len([e for e in entities if e.entity_type == &#39;function&#39;])} functions&quot;
    )

def process_entities(self, entities: List[TestableEntity], total_variants: int, module_path: str) -&gt; None:
    &quot;&quot;&quot;Process each entity and generate tests&quot;&quot;&quot;
    current = 0
    for entity in entities:
        print(f&quot;\nGenerating tests for: {module_path}.{entity.name}&quot;)
        variants = self.generate_test_variants(entity)
        for variant in variants:
            current += 1
            print(f&quot;\rGenerating tests: [{current}/{total_variants}]&quot;, end=&quot;&quot;)
            self.try_generate_test(entity, variant)
    print()

def _get_object(self, path: str) -&gt; Optional[Any]:
    &quot;&quot;&quot;Get the actual object from its module path&quot;&quot;&quot;
    try:
        module_parts = path.split(&#39;.&#39;)
        module_path = &#39;.&#39;.join(module_parts[:-1])
        obj_name = module_parts[-1]

        spec = importlib.util.find_spec(module_path)
        if spec and spec.loader:
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            return getattr(module, obj_name, None)
    except Exception:
        return None

def generate_method_variants(self, entity: TestableEntity) -&gt; List[Dict[str, str]]:
    &quot;&quot;&quot;Generate test variants for methods and instance methods&quot;&quot;&quot;
    if entity.entity_type in {&quot;method&quot;, &quot;instance_method&quot;}:
        method_path = f&quot;{entity.module_path}.{entity.parent_class}.{entity.name}&quot;
    else:
        method_path = f&quot;{entity.module_path}.{entity.name}&quot;

    # Start with basic test with type inference
    variants = [
        self.create_variant(
            &quot;basic&quot;,
            f&quot;--style=unittest --annotate {method_path}&quot;
        )
    ]

    # Add error variant
    variants.append(
        self.create_variant(
            &quot;errors&quot;,
            f&quot;--style=unittest --annotate --except ValueError --except TypeError {method_path}&quot;
        )
    )

    # Add special variants based on method name
    name = entity.name.lower()
    variants.extend(self._generate_special_variants(name, method_path))

    return variants

def _generate_special_variants(self, name: str, method_path: str) -&gt; List[Dict[str, str]]:
    &quot;&quot;&quot;Generate special variants based on method name&quot;&quot;&quot;
    special_variants = []

    if any(x in name for x in [&quot;transform&quot;, &quot;convert&quot;, &quot;process&quot;, &quot;format&quot;]):
        special_variants.append(
            self.create_variant(
                &quot;idempotent&quot;,
                f&quot;--style=unittest --annotate --idempotent {method_path}&quot;
            )
        )

    if any(x in name for x in [&quot;validate&quot;, &quot;verify&quot;, &quot;check&quot;, &quot;assert&quot;]):
        special_variants.append(
            self.create_variant(
                &quot;validation&quot;,
                f&quot;--style=unittest --annotate --errors-equivalent {method_path}&quot;
            )
        )

    if &quot;encode&quot; in name or &quot;decode&quot; in name:
        special_variants.append(
            self.create_variant(
                &quot;roundtrip&quot;,
                f&quot;--style=unittest --annotate --roundtrip {method_path}&quot;
            )
        )

    if any(x in name for x in [&quot;add&quot;, &quot;multiply&quot;, &quot;subtract&quot;, &quot;combine&quot;, &quot;merge&quot;]):
        special_variants.append(
            self.create_variant(
                &quot;binary-op&quot;,
                f&quot;--style=unittest --annotate --binary-op {method_path}&quot;
            )
        )

    return special_variants

def generate_function_variants(self, entity: TestableEntity) -&gt; List[Dict[str, str]]:
    &quot;&quot;&quot;Generate test variants for standalone functions&quot;&quot;&quot;
    base_cmd = f&quot;--style=unittest --annotate {entity.module_path}.{entity.name}&quot;
    variants = [self.create_variant(&quot;basic&quot;, base_cmd)]

    # Add special variants for functions if needed
    name = entity.name.lower()
    if &quot;encode&quot; in name or &quot;decode&quot; in name or &quot;serialize&quot; in name or &quot;deserialize&quot; in name:
        variants.append(self.create_variant(&quot;roundtrip&quot;, f&quot;{base_cmd} --roundtrip&quot;))
    elif any(x in name for x in [&quot;add&quot;, &quot;sub&quot;, &quot;mul&quot;, &quot;combine&quot;, &quot;merge&quot;]):
        variants.append(self.create_variant(&quot;binary-op&quot;, f&quot;{base_cmd} --binary-op&quot;))

    return variants

def generate_test_variants(self, entity: TestableEntity) -&gt; List[Dict[str, str]]:
    &quot;&quot;&quot;Generate all applicable test variants for an entity&quot;&quot;&quot;
    variants = []
    if entity.entity_type == &quot;class&quot;:
        # For classes, just a basic annotated variant
        variants.append(self.create_variant(&quot;basic&quot;, f&quot;--style=unittest --annotate {entity.module_path}.{entity.name}&quot;))
    elif entity.entity_type in {&quot;method&quot;, &quot;instance_method&quot;}:
        variants.extend(self.generate_method_variants(entity))
    else:
        variants.extend(self.generate_function_variants(entity))
    logger.debug(f&quot;Generated variants for {entity.name}: {[v[&#39;type&#39;] for v in variants]}&quot;)
    return variants

def create_variant(self, variant_type: str, cmd: str) -&gt; Dict[str, str]:
    &quot;&quot;&quot;Create a test variant dictionary with properly formatted command&quot;&quot;&quot;
    return {
        &quot;type&quot;: variant_type,
        &quot;cmd&quot;: cmd.strip()  # Ensure no extra whitespace in command
    }

def combine_and_cleanup_tests(self, file_path: Path) -&gt; None:
    &quot;&quot;&quot;
    Combines individual test files into a single file and deletes the originals,
    then removes the combined .py file so only the final markdown remains.

    Args:
        file_path (Path): The original Python file used for test generation.
    &quot;&quot;&quot;
    # Step 1: Derive the combined file name from the original file
    original_stem = file_path.stem  # e.g., &quot;my_module&quot;
    combined_filename = f&quot;test_hyp_{original_stem}.py&quot;
    combined_filepath = self.output_dir / combined_filename

    # Step 2: Collect all generated test files in the output directory
    # Using &quot;test_*.py&quot; so that it naturally ignores any leftover .md files
    test_files = list(self.output_dir.glob(&quot;test_*.py&quot;))

    # Step 3: Combine contents of each test file into a single string
    combined_content = &quot;&quot;
    for test_file in test_files:
        content = test_file.read_text()
        separator = f&quot;\n# ----- {test_file.name} -----\n&quot;
        combined_content += separator + content + &quot;\n&quot;

    # Step 4: Write the combined content to the new file
    combined_filepath.write_text(combined_content)

    # Step 5: Wrap the combined test code with the prompt to produce the final Markdown
    original_source_code = file_path.read_text()
    final_wrapped_content = self.wrap_with_prompt(combined_content, original_source_code)
    final_wrapped_file = self.output_dir / f&quot;test_wrapped_{original_stem}.md&quot;
    final_wrapped_file.write_text(final_wrapped_content)
    logger.info(f&quot;Final wrapped test file created at {final_wrapped_file}&quot;)

    # Optional: verify the combined file
    if not combined_filepath.exists() or len(combined_filepath.read_text()) &lt; 50:
        logger.error(f&quot;Combined test file {combined_filepath} appears to be incomplete.&quot;)
        return

    # Step 6: Cleanup - delete individual test files
    for test_file in test_files:
        try:
            test_file.unlink()
            logger.debug(f&quot;Deleted individual test file: {test_file.name}&quot;)
        except Exception as e:
            logger.error(f&quot;Failed to delete {test_file.name}: {e}&quot;)

    # Step 7: Logging and feedback
    logger.info(f&quot;Combined {len(test_files)} test files into {combined_filename} and removed originals.&quot;)

    # Step 8: Apply Ruff cleaning commands to the combined file
    cmds = [
        f&quot;ruff check {combined_filepath}&quot;,
        f&quot;ruff check --fix {combined_filepath}&quot;,
        f&quot;ruff format {combined_filepath}&quot;,
        f&quot;ruff check --select I --fix {combined_filepath}&quot;,
        f&quot;ruff format {combined_filepath}&quot;
    ]
    for cmd in cmds:
        try:
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            if result.returncode != 0:
                logger.error(f&quot;Ruff command &#39;{cmd}&#39; failed: {result.stderr}&quot;)
            else:
                logger.info(f&quot;Ruff command &#39;{cmd}&#39; succeeded: {result.stdout}&quot;)
        except Exception as e:
            logger.error(f&quot;Failed to run ruff command &#39;{cmd}&#39;: {e}&quot;)

    # Finally, remove the combined .py file so only the markdown remains
    if combined_filepath.exists():
        combined_filepath.unlink()
        logger.info(f&quot;Deleted the combined file {combined_filepath} so that only the Markdown file remains.&quot;)
</code></pre></div>
<p>def parse_args(args: Optional[list] = None) -&gt; Path:
    """
    Parse command line arguments and validate file path.</p>
<div class="highlight"><pre><span></span><code>Args:
    args: Optional list of command line arguments. If None, uses sys.argv[1:]

Returns:
    Path object for the input file

Raises:
    ValueError: If arguments are invalid or file doesn&#39;t exist
&quot;&quot;&quot;
if args is None:
    args = sys.argv[1:]

if len(args) != 1:
    raise ValueError(&quot;Exactly one argument (path to Python file) required&quot;)

file_path = Path(args[0])
if not file_path.exists() or not file_path.is_file():
    raise ValueError(f&quot;File does not exist or is not a file: {file_path}&quot;)

return file_path
</code></pre></div>
<p>def run_test_generation(file_path: Union[str, Path]) -&gt; bool:
    """
    Run the test generation process for a given file.
    Now also calls pre_run_cleanup before generate_all_tests.</p>
<div class="highlight"><pre><span></span><code>Args:
    file_path: Path to the Python file to generate tests for

Returns:
    bool: True if test generation was successful, False otherwise

Raises:
    Exception: If test generation fails
&quot;&quot;&quot;
try:
    if isinstance(file_path, str):
        file_path = Path(file_path)

    logger.info(f&quot;Starting test generator for {file_path}&quot;)
    generator = TestGenerator()

    # Clean up any leftover combined files from prior runs
    generator.pre_run_cleanup()

    # Proceed with the standard generation workflow
    generator.generate_all_tests(file_path)
    return True

except Exception as e:
    logger.error(f&quot;Test generation failed: {e}&quot;, exc_info=True)
    return False
</code></pre></div>
<p>def main(args: Optional[list] = None) -&gt; int:
    """
    Main entry point for the test generator script.</p>
<div class="highlight"><pre><span></span><code>Args:
    args: Optional list of command line arguments. If None, uses sys.argv[1:]

Returns:
    int: Exit code (0 for success, 1 for failure)
&quot;&quot;&quot;
try:
    file_path = parse_args(args)
    success = run_test_generation(file_path)
    return 0 if success else 1

except ValueError as e:
    print(f&quot;Error: {e}&quot;)
    logger.error(f&quot;Invalid arguments: {e}&quot;)
    print(&quot;Usage: python test_generator.py &lt;path_to_python_file&gt;&quot;)
    return 1

except Exception as e:
    print(f&quot;Unexpected error: {e}&quot;)
    logger.error(&quot;Unexpected error during execution&quot;, exc_info=True)
    return 1
</code></pre></div>
<p>if <strong>name</strong> == "<strong>main</strong>":
    sys.exit(main())</p>
<p>Where:
       </p>
<h1 id="-test_testgenerator_generate_test_variants_basicpy-_1">----- test_TestGenerator_generate_test_variants_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorgenerate_Test_Variants(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())))
def test_fuzz_TestGenerator_generate_test_variants(self, entity: hypot_test_gen.TestableEntity) -&gt; None:
    hypot_test_gen.TestGenerator.generate_test_variants(self=self, entity=entity)
</code></pre></div>
<h1 id="-test_testgenerator_write_and_verify_output_errorspy-_1">----- test_TestGenerator_write_and_verify_output_errors.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, reject, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorwrite_And_Verify_Output(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), output_file=st.from_type(pathlib.Path), content=st.text())
def test_fuzz_TestGenerator_write_and_verify_output(self, output_file: pathlib.Path, content: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.write_and_verify_output(self=self, output_file=output_file, content=content)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_process_entities_idempotentpy-_1">----- test_TestGenerator_process_entities_idempotent.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestIdempotentTestgeneratorprocess_Entities(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entities=st.lists(st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text()))), total_variants=st.integers(), module_path=st.text())
def test_idempotent_TestGenerator_process_entities(self, entities: typing.List[hypot_test_gen.TestableEntity], total_variants: int, module_path: str) -&gt; None:
    result = hypot_test_gen.TestGenerator.process_entities(self=self, entities=entities, total_variants=total_variants, module_path=module_path)
    repeat = hypot_test_gen.TestGenerator.process_entities(self=result, entities=entities, total_variants=total_variants, module_path=module_path)
    self.assertEqual(result, repeat)
</code></pre></div>
<h1 id="-test_testgenerator_handle_generated_output_errorspy-_1">----- test_TestGenerator_handle_generated_output_errors.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorhandle_Generated_Output(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())), variant=st.dictionaries(keys=st.text(), values=st.text()), output=st.text())
def test_fuzz_TestGenerator_handle_generated_output(self, entity: hypot_test_gen.TestableEntity, variant: typing.Dict[str, str], output: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.handle_generated_output(self=self, entity=entity, variant=variant, output=output)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_process_hypothesis_result_idempotentpy-_1">----- test_TestGenerator_process_hypothesis_result_idempotent.py -----</h1>
<p>import hypot_test_gen
import subprocess
import unittest
from hypothesis import given, strategies as st
from subprocess import CompletedProcess</p>
<p>class TestIdempotentTestgeneratorprocess_Hypothesis_Result(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), result=st.from_type(subprocess.CompletedProcess))
def test_idempotent_TestGenerator_process_hypothesis_result(self, result: subprocess.CompletedProcess) -&gt; None:
    result = hypot_test_gen.TestGenerator.process_hypothesis_result(self=self, result=result)
    repeat = hypot_test_gen.TestGenerator.process_hypothesis_result(self=result, result=result)
    self.assertEqual(result, repeat)
</code></pre></div>
<h1 id="-test_testgenerator_extract_imports_errorspy-_1">----- test_TestGenerator_extract_imports_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorextract_Imports(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), content=st.text())
def test_fuzz_TestGenerator_extract_imports(self, content: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.extract_imports(self=self, content=content)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_process_method_errorspy-_1">----- test_ModuleParser_process_method_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzModuleparserprocess_Method(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_ModuleParser_process_method(self, node: ast.FunctionDef) -&gt; None:
    try:
        hypot_test_gen.ModuleParser.process_method(self=self, node=node)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_generate_test_variants_errorspy-_1">----- test_TestGenerator_generate_test_variants_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorgenerate_Test_Variants(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())))
def test_fuzz_TestGenerator_generate_test_variants(self, entity: hypot_test_gen.TestableEntity) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.generate_test_variants(self=self, entity=entity)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testfixer_visit_functiondef_errorspy-_1">----- test_TestFixer_visit_FunctionDef_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestfixervisit_Functiondef(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_TestFixer_visit_FunctionDef(self, node: ast.FunctionDef) -&gt; None:
    try:
        hypot_test_gen.TestFixer.visit_FunctionDef(self=self, node=node)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_verify_output_dir_validationpy-_1">----- test_TestGenerator_verify_output_dir_validation.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorverify_Output_Dir(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_verify_output_dir(self) -&gt; None:
    hypot_test_gen.TestGenerator.verify_output_dir(self=self)
</code></pre></div>
<h1 id="-test_moduleparser_get_base_name_basicpy-_1">----- test_ModuleParser_get_base_name_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import AST
from hypothesis import given, strategies as st</p>
<p>class TestFuzzModuleparserget_Base_Name(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), base=st.builds(AST))
def test_fuzz_ModuleParser_get_base_name(self, base: ast.AST) -&gt; None:
    hypot_test_gen.ModuleParser.get_base_name(self=self, base=base)
</code></pre></div>
<h1 id="-test_fix_pythonpath_basicpy-_1">----- test_fix_pythonpath_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzFix_Pythonpath(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(file_path=st.from_type(pathlib.Path))
def test_fuzz_fix_pythonpath(self, file_path: pathlib.Path) -&gt; None:
    hypot_test_gen.fix_pythonpath(file_path=file_path)
</code></pre></div>
<h1 id="-test_testgenerator_verify_output_dir_basicpy-_1">----- test_TestGenerator_verify_output_dir_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorverify_Output_Dir(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_verify_output_dir(self) -&gt; None:
    hypot_test_gen.TestGenerator.verify_output_dir(self=self)
</code></pre></div>
<h1 id="-test_testgenerator_log_environment_errorspy-_1">----- test_TestGenerator_log_environment_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorlog_Environment(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_log_environment(self) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.log_environment(self=self)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_prepare_environment_errorspy-_1">----- test_TestGenerator_prepare_environment_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorprepare_Environment(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_prepare_environment(self) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.prepare_environment(self=self)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_remove_logger_lines_basicpy-_1">----- test_remove_logger_lines_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzRemove_Logger_Lines(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(text=st.text())
def test_fuzz_remove_logger_lines(self, text: str) -&gt; None:
    hypot_test_gen.remove_logger_lines(text=text)
</code></pre></div>
<h1 id="-test_construct_src_path_basicpy-_1">----- test_construct_src_path_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzConstruct_Src_Path(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(file_path=st.from_type(pathlib.Path))
def test_fuzz_construct_src_path(self, file_path: pathlib.Path) -&gt; None:
    hypot_test_gen.construct_src_path(file_path=file_path)
</code></pre></div>
<h1 id="-test_debug_command_output_basicpy-_1">----- test_debug_command_output_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzDebug_Command_Output(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(cmd=st.text(), stdout=st.text(), stderr=st.text(), returncode=st.integers())
def test_fuzz_debug_command_output(self, cmd: str, stdout: str, stderr: str, returncode: int) -&gt; None:
    hypot_test_gen.debug_command_output(cmd=cmd, stdout=stdout, stderr=stderr, returncode=returncode)
</code></pre></div>
<h1 id="-test_parse_args_basicpy-_1">----- test_parse_args_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzParse_Args(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(args=st.one_of(st.none(), st.builds(list)))
def test_fuzz_parse_args(self, args: typing.Optional[list]) -&gt; None:
    hypot_test_gen.parse_args(args=args)
</code></pre></div>
<h1 id="-test_testgenerator_get_module_contents_basicpy-_1">----- test_TestGenerator_get_module_contents_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorget_Module_Contents(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), file_path=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator_get_module_contents(self, file_path: pathlib.Path) -&gt; None:
    hypot_test_gen.TestGenerator.get_module_contents(self=self, file_path=file_path)
</code></pre></div>
<h1 id="-test_moduleparser_process_method_basicpy-_1">----- test_ModuleParser_process_method_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, strategies as st</p>
<p>class TestFuzzModuleparserprocess_Method(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_ModuleParser_process_method(self, node: ast.FunctionDef) -&gt; None:
    hypot_test_gen.ModuleParser.process_method(self=self, node=node)
</code></pre></div>
<h1 id="-test_testgenerator_combine_and_cleanup_tests_basicpy-_1">----- test_TestGenerator_combine_and_cleanup_tests_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorcombine_And_Cleanup_Tests(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), file_path=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator_combine_and_cleanup_tests(self, file_path: pathlib.Path) -&gt; None:
    hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=self, file_path=file_path)
</code></pre></div>
<h1 id="-test_testgenerator_generate_all_tests_basicpy-_1">----- test_TestGenerator_generate_all_tests_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorgenerate_All_Tests(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), file_path=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator_generate_all_tests(self, file_path: pathlib.Path) -&gt; None:
    hypot_test_gen.TestGenerator.generate_all_tests(self=self, file_path=file_path)
</code></pre></div>
<h1 id="-test_testgenerator_try_generate_test_basicpy-_1">----- test_TestGenerator_try_generate_test_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratortry_Generate_Test(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())), variant=st.dictionaries(keys=st.text(), values=st.text()), max_retries=st.integers())
def test_fuzz_TestGenerator_try_generate_test(self, entity: hypot_test_gen.TestableEntity, variant: typing.Dict[str, str], max_retries: int) -&gt; None:
    hypot_test_gen.TestGenerator.try_generate_test(self=self, entity=entity, variant=variant, max_retries=max_retries)
</code></pre></div>
<h1 id="-test_moduleparser_add_function_entity_basicpy-_1">----- test_ModuleParser_add_function_entity_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, strategies as st</p>
<p>class TestFuzzModuleparseradd_Function_Entity(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_ModuleParser_add_function_entity(self, node: ast.FunctionDef) -&gt; None:
    hypot_test_gen.ModuleParser.add_function_entity(self=self, node=node)
</code></pre></div>
<h1 id="-test_testgenerator_populate_entities_basicpy-_1">----- test_TestGenerator_populate_entities_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypot_test_gen import ModuleParser
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorpopulate_Entities(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), parser=st.builds(ModuleParser), module_path=st.text())
def test_fuzz_TestGenerator_populate_entities(self, parser: hypot_test_gen.ModuleParser, module_path: str) -&gt; None:
    hypot_test_gen.TestGenerator.populate_entities(self=self, parser=parser, module_path=module_path)
</code></pre></div>
<h1 id="-test_fix_leading_zeros_basicpy-_1">----- test_fix_leading_zeros_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzFix_Leading_Zeros(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(test_code=st.text())
def test_fuzz_fix_leading_zeros(self, test_code: str) -&gt; None:
    hypot_test_gen.fix_leading_zeros(test_code=test_code)
</code></pre></div>
<h1 id="-test_testgenerator_construct_module_path_errorspy-_1">----- test_TestGenerator_construct_module_path_errors.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, reject, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorconstruct_Module_Path(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), file_path=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator_construct_module_path(self, file_path: pathlib.Path) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.construct_module_path(self=self, file_path=file_path)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_get_module_contents_errorspy-_1">----- test_TestGenerator_get_module_contents_errors.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, reject, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorget_Module_Contents(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), file_path=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator_get_module_contents(self, file_path: pathlib.Path) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.get_module_contents(self=self, file_path=file_path)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_create_variant_basicpy-_1">----- test_TestGenerator_create_variant_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorcreate_Variant(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), variant_type=st.text(), cmd=st.text())
def test_fuzz_TestGenerator_create_variant(self, variant_type: str, cmd: str) -&gt; None:
    hypot_test_gen.TestGenerator.create_variant(self=self, variant_type=variant_type, cmd=cmd)
</code></pre></div>
<h1 id="-test_run_test_generation_basicpy-_1">----- test_run_test_generation_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import typing
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzRun_Test_Generation(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(file_path=st.from_type(typing.Union[str, pathlib.Path]))
def test_fuzz_run_test_generation(self, file_path: typing.Union[str, pathlib.Path]) -&gt; None:
    hypot_test_gen.run_test_generation(file_path=file_path)
</code></pre></div>
<h1 id="-test_testgenerator_construct_module_path_basicpy-_1">----- test_TestGenerator_construct_module_path_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorconstruct_Module_Path(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), file_path=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator_construct_module_path(self, file_path: pathlib.Path) -&gt; None:
    hypot_test_gen.TestGenerator.construct_module_path(self=self, file_path=file_path)
</code></pre></div>
<h1 id="-test_moduleparser_add_class_entity_basicpy-_1">----- test_ModuleParser_add_class_entity_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import ClassDef
from hypothesis import given, strategies as st</p>
<p>class TestFuzzModuleparseradd_Class_Entity(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(ClassDef))
def test_fuzz_ModuleParser_add_class_entity(self, node: ast.ClassDef) -&gt; None:
    hypot_test_gen.ModuleParser.add_class_entity(self=self, node=node)
</code></pre></div>
<h1 id="-test_testgenerator_extract_imports_basicpy-_1">----- test_TestGenerator_extract_imports_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorextract_Imports(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), content=st.text())
def test_fuzz_TestGenerator_extract_imports(self, content: str) -&gt; None:
    hypot_test_gen.TestGenerator.extract_imports(self=self, content=content)
</code></pre></div>
<h1 id="-test_testfixer_visit_functiondef_basicpy-_1">----- test_TestFixer_visit_FunctionDef_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestfixervisit_Functiondef(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_TestFixer_visit_FunctionDef(self, node: ast.FunctionDef) -&gt; None:
    hypot_test_gen.TestFixer.visit_FunctionDef(self=self, node=node)
</code></pre></div>
<h1 id="-test_testgenerator_write_and_verify_output_validationpy-_1">----- test_TestGenerator_write_and_verify_output_validation.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorwrite_And_Verify_Output(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), output_file=st.from_type(pathlib.Path), content=st.text())
def test_fuzz_TestGenerator_write_and_verify_output(self, output_file: pathlib.Path, content: str) -&gt; None:
    hypot_test_gen.TestGenerator.write_and_verify_output(self=self, output_file=output_file, content=content)
</code></pre></div>
<h1 id="-test_testgenerator_wrap_with_prompt_errorspy-_1">----- test_TestGenerator_wrap_with_prompt_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorwrap_With_Prompt(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), combined_test_code=st.text(), original_source_code=st.text())
def test_fuzz_TestGenerator_wrap_with_prompt(self, combined_test_code: str, original_source_code: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.wrap_with_prompt(self=self, combined_test_code=combined_test_code, original_source_code=original_source_code)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_combine_and_cleanup_tests_errorspy-_1">----- test_TestGenerator_combine_and_cleanup_tests_errors.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, reject, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorcombine_And_Cleanup_Tests(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), file_path=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator_combine_and_cleanup_tests(self, file_path: pathlib.Path) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=self, file_path=file_path)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_get_base_name_errorspy-_1">----- test_ModuleParser_get_base_name_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import AST
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzModuleparserget_Base_Name(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), base=st.builds(AST))
def test_fuzz_ModuleParser_get_base_name(self, base: ast.AST) -&gt; None:
    try:
        hypot_test_gen.ModuleParser.get_base_name(self=self, base=base)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_main_basicpy-_1">----- test_main_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzMain(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(args=st.one_of(st.none(), st.builds(list)))
def test_fuzz_main(self, args: typing.Optional[list]) -&gt; None:
    hypot_test_gen.main(args=args)
</code></pre></div>
<h1 id="-test_testgenerator_display_module_info_errorspy-_1">----- test_TestGenerator_display_module_info_errors.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratordisplay_Module_Info(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), module_path=st.text(), entities=st.lists(st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text()))))
def test_fuzz_TestGenerator_display_module_info(self, module_path: str, entities: typing.List[hypot_test_gen.TestableEntity]) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.display_module_info(self=self, module_path=module_path, entities=entities)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_prepare_environment_basicpy-_1">----- test_TestGenerator_prepare_environment_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorprepare_Environment(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_prepare_environment(self) -&gt; None:
    hypot_test_gen.TestGenerator.prepare_environment(self=self)
</code></pre></div>
<h1 id="-test_testgenerator_try_generate_test_errorspy-_1">----- test_TestGenerator_try_generate_test_errors.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratortry_Generate_Test(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())), variant=st.dictionaries(keys=st.text(), values=st.text()), max_retries=st.integers())
def test_fuzz_TestGenerator_try_generate_test(self, entity: hypot_test_gen.TestableEntity, variant: typing.Dict[str, str], max_retries: int) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.try_generate_test(self=self, entity=entity, variant=variant, max_retries=max_retries)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_generate_function_variants_errorspy-_1">----- test_TestGenerator_generate_function_variants_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorgenerate_Function_Variants(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())))
def test_fuzz_TestGenerator_generate_function_variants(self, entity: hypot_test_gen.TestableEntity) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.generate_function_variants(self=self, entity=entity)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_generate_function_variants_basicpy-_1">----- test_TestGenerator_generate_function_variants_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorgenerate_Function_Variants(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())))
def test_fuzz_TestGenerator_generate_function_variants(self, entity: hypot_test_gen.TestableEntity) -&gt; None:
    hypot_test_gen.TestGenerator.generate_function_variants(self=self, entity=entity)
</code></pre></div>
<h1 id="-test_moduleparser_add_function_entity_errorspy-_1">----- test_ModuleParser_add_function_entity_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzModuleparseradd_Function_Entity(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_ModuleParser_add_function_entity(self, node: ast.FunctionDef) -&gt; None:
    try:
        hypot_test_gen.ModuleParser.add_function_entity(self=self, node=node)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_add_class_entity_errorspy-_1">----- test_ModuleParser_add_class_entity_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import ClassDef
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzModuleparseradd_Class_Entity(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(ClassDef))
def test_fuzz_ModuleParser_add_class_entity(self, node: ast.ClassDef) -&gt; None:
    try:
        hypot_test_gen.ModuleParser.add_class_entity(self=self, node=node)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_basicpy-_1">----- test_TestGenerator_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgenerator(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(output_dir=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator(self, output_dir: pathlib.Path) -&gt; None:
    hypot_test_gen.TestGenerator(output_dir=output_dir)
</code></pre></div>
<h1 id="-test_testgenerator_process_entities_basicpy-_1">----- test_TestGenerator_process_entities_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorprocess_Entities(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entities=st.lists(st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text()))), total_variants=st.integers(), module_path=st.text())
def test_fuzz_TestGenerator_process_entities(self, entities: typing.List[hypot_test_gen.TestableEntity], total_variants: int, module_path: str) -&gt; None:
    hypot_test_gen.TestGenerator.process_entities(self=self, entities=entities, total_variants=total_variants, module_path=module_path)
</code></pre></div>
<h1 id="-test_moduleparser_determine_instance_method_errorspy-_1">----- test_ModuleParser_determine_instance_method_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzModuleparserdetermine_Instance_Method(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_ModuleParser_determine_instance_method(self, node: ast.FunctionDef) -&gt; None:
    try:
        hypot_test_gen.ModuleParser.determine_instance_method(self=self, node=node)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_should_skip_method_basicpy-_1">----- test_ModuleParser_should_skip_method_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, strategies as st</p>
<p>class TestFuzzModuleparsershould_Skip_Method(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_ModuleParser_should_skip_method(self, node: ast.FunctionDef) -&gt; None:
    hypot_test_gen.ModuleParser.should_skip_method(self=self, node=node)
</code></pre></div>
<h1 id="-test_testgenerator_process_hypothesis_result_errorspy-_1">----- test_TestGenerator_process_hypothesis_result_errors.py -----</h1>
<p>import hypot_test_gen
import subprocess
import unittest
from hypothesis import given, reject, strategies as st
from subprocess import CompletedProcess</p>
<p>class TestFuzzTestgeneratorprocess_Hypothesis_Result(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), result=st.from_type(subprocess.CompletedProcess))
def test_fuzz_TestGenerator_process_hypothesis_result(self, result: subprocess.CompletedProcess) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.process_hypothesis_result(self=self, result=result)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_combine_and_cleanup_tests_binary-oppy-_1">----- test_TestGenerator_combine_and_cleanup_tests_binary-op.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestBinaryOperationcombine_and_cleanup_tests(unittest.TestCase):
    combine_and_cleanup_tests_operands = st.from_type(pathlib.Path)</p>
<div class="highlight"><pre><span></span><code>@given(a=combine_and_cleanup_tests_operands, b=combine_and_cleanup_tests_operands, c=combine_and_cleanup_tests_operands)
def test_associative_binary_operation_TestGenerator_combine_and_cleanup_tests(self, a, b, c) -&gt; None:
    left = hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=a, file_path=hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=b, file_path=c))
    right = hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=a, file_path=b), file_path=c)
    self.assertEqual(left, right)

@given(a=combine_and_cleanup_tests_operands, b=combine_and_cleanup_tests_operands)
def test_commutative_binary_operation_TestGenerator_combine_and_cleanup_tests(self, a, b) -&gt; None:
    left = hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=a, file_path=b)
    right = hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=b, file_path=a)
    self.assertEqual(left, right)

@given(a=combine_and_cleanup_tests_operands)
def test_identity_binary_operation_TestGenerator_combine_and_cleanup_tests(self, a) -&gt; None:
    identity = PosixPath(&#39;.&#39;)
    self.assertEqual(a, hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=a, file_path=identity))
    self.assertEqual(a, hypot_test_gen.TestGenerator.combine_and_cleanup_tests(self=identity, file_path=a))
</code></pre></div>
<h1 id="-test_testgenerator_log_entities_summary_errorspy-_1">----- test_TestGenerator_log_entities_summary_errors.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorlog_Entities_Summary(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entities=st.lists(st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text()))))
def test_fuzz_TestGenerator_log_entities_summary(self, entities: typing.List[hypot_test_gen.TestableEntity]) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.log_entities_summary(self=self, entities=entities)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_should_skip_method_errorspy-_1">----- test_ModuleParser_should_skip_method_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzModuleparsershould_Skip_Method(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_ModuleParser_should_skip_method(self, node: ast.FunctionDef) -&gt; None:
    try:
        hypot_test_gen.ModuleParser.should_skip_method(self=self, node=node)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_process_class_contents_idempotentpy-_1">----- test_ModuleParser_process_class_contents_idempotent.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import ClassDef
from hypothesis import given, strategies as st</p>
<p>class TestIdempotentModuleparserprocess_Class_Contents(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(ClassDef))
def test_idempotent_ModuleParser_process_class_contents(self, node: ast.ClassDef) -&gt; None:
    result = hypot_test_gen.ModuleParser.process_class_contents(self=self, node=node)
    repeat = hypot_test_gen.ModuleParser.process_class_contents(self=result, node=node)
    self.assertEqual(result, repeat)
</code></pre></div>
<h1 id="-test_testgenerator_handle_failed_attempt_basicpy-_1">----- test_TestGenerator_handle_failed_attempt_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorhandle_Failed_Attempt(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())), variant=st.dictionaries(keys=st.text(), values=st.text()), attempt=st.integers())
def test_fuzz_TestGenerator_handle_failed_attempt(self, entity: hypot_test_gen.TestableEntity, variant: typing.Dict[str, str], attempt: int) -&gt; None:
    hypot_test_gen.TestGenerator.handle_failed_attempt(self=self, entity=entity, variant=variant, attempt=attempt)
</code></pre></div>
<h1 id="-test_testgenerator_attempt_test_generation_basicpy-_1">----- test_TestGenerator_attempt_test_generation_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorattempt_Test_Generation(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())), variant=st.dictionaries(keys=st.text(), values=st.text()), attempt=st.integers())
def test_fuzz_TestGenerator_attempt_test_generation(self, entity: hypot_test_gen.TestableEntity, variant: typing.Dict[str, str], attempt: int) -&gt; None:
    hypot_test_gen.TestGenerator.attempt_test_generation(self=self, entity=entity, variant=variant, attempt=attempt)
</code></pre></div>
<h1 id="-test_testgenerator_is_known_error_basicpy-_1">----- test_TestGenerator_is_known_error_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratoris_Known_Error(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), stderr=st.text())
def test_fuzz_TestGenerator_is_known_error(self, stderr: str) -&gt; None:
    hypot_test_gen.TestGenerator.is_known_error(self=self, stderr=stderr)
</code></pre></div>
<h1 id="-test_testgenerator_post_process_test_content_basicpy-_1">----- test_TestGenerator_post_process_test_content_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorpost_Process_Test_Content(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), content=st.text())
def test_fuzz_TestGenerator_post_process_test_content(self, content: str) -&gt; None:
    hypot_test_gen.TestGenerator.post_process_test_content(self=self, content=content)
</code></pre></div>
<h1 id="-test_moduleparser_add_function_entity_binary-oppy-_1">----- test_ModuleParser_add_function_entity_binary-op.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestBinaryOperationadd_function_entity(unittest.TestCase):
    add_function_entity_operands = st.builds(FunctionDef)</p>
<div class="highlight"><pre><span></span><code>@given(a=add_function_entity_operands, b=add_function_entity_operands, c=add_function_entity_operands)
def test_associative_binary_operation_ModuleParser_add_function_entity(self, a, b, c) -&gt; None:
    left = hypot_test_gen.ModuleParser.add_function_entity(self=a, node=hypot_test_gen.ModuleParser.add_function_entity(self=b, node=c))
    right = hypot_test_gen.ModuleParser.add_function_entity(self=hypot_test_gen.ModuleParser.add_function_entity(self=a, node=b), node=c)
    self.assertEqual(left, right)

@given(a=add_function_entity_operands, b=add_function_entity_operands)
def test_commutative_binary_operation_ModuleParser_add_function_entity(self, a, b) -&gt; None:
    left = hypot_test_gen.ModuleParser.add_function_entity(self=a, node=b)
    right = hypot_test_gen.ModuleParser.add_function_entity(self=b, node=a)
    self.assertEqual(left, right)

@given(a=add_function_entity_operands)
def test_identity_binary_operation_ModuleParser_add_function_entity(self, a) -&gt; None:
    identity = &#39;&lt;ast.FunctionDef object at 0x125566c20&gt;&#39;
    self.assertEqual(a, hypot_test_gen.ModuleParser.add_function_entity(self=a, node=identity))
    self.assertEqual(a, hypot_test_gen.ModuleParser.add_function_entity(self=identity, node=a))
</code></pre></div>
<h1 id="-test_testgenerator_create_variant_errorspy-_1">----- test_TestGenerator_create_variant_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorcreate_Variant(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), variant_type=st.text(), cmd=st.text())
def test_fuzz_TestGenerator_create_variant(self, variant_type: str, cmd: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.create_variant(self=self, variant_type=variant_type, cmd=cmd)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_run_hypothesis_write_basicpy-_1">----- test_TestGenerator_run_hypothesis_write_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorrun_Hypothesis_Write(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), command=st.text())
def test_fuzz_TestGenerator_run_hypothesis_write(self, command: str) -&gt; None:
    hypot_test_gen.TestGenerator.run_hypothesis_write(self=self, command=command)
</code></pre></div>
<h1 id="-test_moduleparser_determine_instance_method_basicpy-_1">----- test_ModuleParser_determine_instance_method_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, strategies as st</p>
<p>class TestFuzzModuleparserdetermine_Instance_Method(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_fuzz_ModuleParser_determine_instance_method(self, node: ast.FunctionDef) -&gt; None:
    hypot_test_gen.ModuleParser.determine_instance_method(self=self, node=node)
</code></pre></div>
<h1 id="-test_testgenerator_display_module_info_basicpy-_1">----- test_TestGenerator_display_module_info_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratordisplay_Module_Info(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), module_path=st.text(), entities=st.lists(st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text()))))
def test_fuzz_TestGenerator_display_module_info(self, module_path: str, entities: typing.List[hypot_test_gen.TestableEntity]) -&gt; None:
    hypot_test_gen.TestGenerator.display_module_info(self=self, module_path=module_path, entities=entities)
</code></pre></div>
<h1 id="-test_moduleparser_process_class_contents_basicpy-_1">----- test_ModuleParser_process_class_contents_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import ClassDef
from hypothesis import given, strategies as st</p>
<p>class TestFuzzModuleparserprocess_Class_Contents(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(ClassDef))
def test_fuzz_ModuleParser_process_class_contents(self, node: ast.ClassDef) -&gt; None:
    hypot_test_gen.ModuleParser.process_class_contents(self=self, node=node)
</code></pre></div>
<h1 id="-test_testgenerator_parse_ast_basicpy-_1">----- test_TestGenerator_parse_ast_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorparse_Ast(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), content=st.text())
def test_fuzz_TestGenerator_parse_ast(self, content: str) -&gt; None:
    hypot_test_gen.TestGenerator.parse_ast(self=self, content=content)
</code></pre></div>
<h1 id="-test_testgenerator_process_entities_errorspy-_1">----- test_TestGenerator_process_entities_errors.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorprocess_Entities(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entities=st.lists(st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text()))), total_variants=st.integers(), module_path=st.text())
def test_fuzz_TestGenerator_process_entities(self, entities: typing.List[hypot_test_gen.TestableEntity], total_variants: int, module_path: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.process_entities(self=self, entities=entities, total_variants=total_variants, module_path=module_path)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_store_class_bases_errorspy-_1">----- test_ModuleParser_store_class_bases_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import ClassDef
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzModuleparserstore_Class_Bases(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(ClassDef))
def test_fuzz_ModuleParser_store_class_bases(self, node: ast.ClassDef) -&gt; None:
    try:
        hypot_test_gen.ModuleParser.store_class_bases(self=self, node=node)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_run_hypothesis_write_errorspy-_1">----- test_TestGenerator_run_hypothesis_write_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorrun_Hypothesis_Write(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), command=st.text())
def test_fuzz_TestGenerator_run_hypothesis_write(self, command: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.run_hypothesis_write(self=self, command=command)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_wrap_with_prompt_basicpy-_1">----- test_TestGenerator_wrap_with_prompt_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorwrap_With_Prompt(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), combined_test_code=st.text(), original_source_code=st.text())
def test_fuzz_TestGenerator_wrap_with_prompt(self, combined_test_code: str, original_source_code: str) -&gt; None:
    hypot_test_gen.TestGenerator.wrap_with_prompt(self=self, combined_test_code=combined_test_code, original_source_code=original_source_code)
</code></pre></div>
<h1 id="-test_testgenerator_pre_run_cleanup_errorspy-_1">----- test_TestGenerator_pre_run_cleanup_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorpre_Run_Cleanup(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_pre_run_cleanup(self) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.pre_run_cleanup(self=self)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testableentity_basicpy-_1">----- test_TestableEntity_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestableentity(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(name=st.text(), module_path=st.text(), entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), parent_class=st.one_of(st.none(), st.text()))
def test_fuzz_TestableEntity(self, name: str, module_path: str, entity_type, parent_class: typing.Optional[str]) -&gt; None:
    hypot_test_gen.TestableEntity(name=name, module_path=module_path, entity_type=entity_type, parent_class=parent_class)
</code></pre></div>
<h1 id="-test_testgenerator_write_and_verify_output_basicpy-_1">----- test_TestGenerator_write_and_verify_output_basic.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorwrite_And_Verify_Output(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), output_file=st.from_type(pathlib.Path), content=st.text())
def test_fuzz_TestGenerator_write_and_verify_output(self, output_file: pathlib.Path, content: str) -&gt; None:
    hypot_test_gen.TestGenerator.write_and_verify_output(self=self, output_file=output_file, content=content)
</code></pre></div>
<h1 id="-test_fix_duplicate_self_basicpy-_1">----- test_fix_duplicate_self_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzFix_Duplicate_Self(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(test_content=st.text())
def test_fuzz_fix_duplicate_self(self, test_content: str) -&gt; None:
    hypot_test_gen.fix_duplicate_self(test_content=test_content)
</code></pre></div>
<h1 id="-test_testgenerator_is_known_error_errorspy-_1">----- test_TestGenerator_is_known_error_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratoris_Known_Error(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), stderr=st.text())
def test_fuzz_TestGenerator_is_known_error(self, stderr: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.is_known_error(self=self, stderr=stderr)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_process_class_contents_errorspy-_1">----- test_ModuleParser_process_class_contents_errors.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import ClassDef
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzModuleparserprocess_Class_Contents(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(ClassDef))
def test_fuzz_ModuleParser_process_class_contents(self, node: ast.ClassDef) -&gt; None:
    try:
        hypot_test_gen.ModuleParser.process_class_contents(self=self, node=node)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_generate_all_tests_errorspy-_1">----- test_TestGenerator_generate_all_tests_errors.py -----</h1>
<p>import hypot_test_gen
import pathlib
import unittest
from hypothesis import given, reject, strategies as st
from pathlib import Path</p>
<p>class TestFuzzTestgeneratorgenerate_All_Tests(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), file_path=st.from_type(pathlib.Path))
def test_fuzz_TestGenerator_generate_all_tests(self, file_path: pathlib.Path) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.generate_all_tests(self=self, file_path=file_path)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_post_process_test_content_errorspy-_1">----- test_TestGenerator_post_process_test_content_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorpost_Process_Test_Content(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), content=st.text())
def test_fuzz_TestGenerator_post_process_test_content(self, content: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.post_process_test_content(self=self, content=content)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_add_class_entity_binary-oppy-_1">----- test_ModuleParser_add_class_entity_binary-op.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestBinaryOperationadd_class_entity(unittest.TestCase):
    add_class_entity_operands = st.builds(ClassDef)</p>
<div class="highlight"><pre><span></span><code>@given(a=add_class_entity_operands, b=add_class_entity_operands, c=add_class_entity_operands)
def test_associative_binary_operation_ModuleParser_add_class_entity(self, a, b, c) -&gt; None:
    left = hypot_test_gen.ModuleParser.add_class_entity(self=a, node=hypot_test_gen.ModuleParser.add_class_entity(self=b, node=c))
    right = hypot_test_gen.ModuleParser.add_class_entity(self=hypot_test_gen.ModuleParser.add_class_entity(self=a, node=b), node=c)
    self.assertEqual(left, right)

@given(a=add_class_entity_operands, b=add_class_entity_operands)
def test_commutative_binary_operation_ModuleParser_add_class_entity(self, a, b) -&gt; None:
    left = hypot_test_gen.ModuleParser.add_class_entity(self=a, node=b)
    right = hypot_test_gen.ModuleParser.add_class_entity(self=b, node=a)
    self.assertEqual(left, right)

@given(a=add_class_entity_operands)
def test_identity_binary_operation_ModuleParser_add_class_entity(self, a) -&gt; None:
    identity = &#39;&lt;ast.ClassDef object at 0x125deec50&gt;&#39;
    self.assertEqual(a, hypot_test_gen.ModuleParser.add_class_entity(self=a, node=identity))
    self.assertEqual(a, hypot_test_gen.ModuleParser.add_class_entity(self=identity, node=a))
</code></pre></div>
<h1 id="-test_testgenerator_verify_output_dir_errorspy-_1">----- test_TestGenerator_verify_output_dir_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorverify_Output_Dir(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_verify_output_dir(self) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.verify_output_dir(self=self)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_handle_generated_output_basicpy-_1">----- test_TestGenerator_handle_generated_output_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorhandle_Generated_Output(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())), variant=st.dictionaries(keys=st.text(), values=st.text()), output=st.text())
def test_fuzz_TestGenerator_handle_generated_output(self, entity: hypot_test_gen.TestableEntity, variant: typing.Dict[str, str], output: str) -&gt; None:
    hypot_test_gen.TestGenerator.handle_generated_output(self=self, entity=entity, variant=variant, output=output)
</code></pre></div>
<h1 id="-test_moduleparser_process_method_idempotentpy-_1">----- test_ModuleParser_process_method_idempotent.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import FunctionDef
from hypothesis import given, strategies as st</p>
<p>class TestIdempotentModuleparserprocess_Method(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(FunctionDef))
def test_idempotent_ModuleParser_process_method(self, node: ast.FunctionDef) -&gt; None:
    result = hypot_test_gen.ModuleParser.process_method(self=self, node=node)
    repeat = hypot_test_gen.ModuleParser.process_method(self=result, node=node)
    self.assertEqual(result, repeat)
</code></pre></div>
<h1 id="-test_testgenerator_process_hypothesis_result_basicpy-_1">----- test_TestGenerator_process_hypothesis_result_basic.py -----</h1>
<p>import hypot_test_gen
import subprocess
import unittest
from hypothesis import given, strategies as st
from subprocess import CompletedProcess</p>
<p>class TestFuzzTestgeneratorprocess_Hypothesis_Result(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), result=st.from_type(subprocess.CompletedProcess))
def test_fuzz_TestGenerator_process_hypothesis_result(self, result: subprocess.CompletedProcess) -&gt; None:
    hypot_test_gen.TestGenerator.process_hypothesis_result(self=self, result=result)
</code></pre></div>
<h1 id="-test_testgenerator_generate_method_variants_basicpy-_1">----- test_TestGenerator_generate_method_variants_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorgenerate_Method_Variants(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())))
def test_fuzz_TestGenerator_generate_method_variants(self, entity: hypot_test_gen.TestableEntity) -&gt; None:
    hypot_test_gen.TestGenerator.generate_method_variants(self=self, entity=entity)
</code></pre></div>
<h1 id="-test_testgenerator_post_process_test_content_idempotentpy-_1">----- test_TestGenerator_post_process_test_content_idempotent.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestIdempotentTestgeneratorpost_Process_Test_Content(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), content=st.text())
def test_idempotent_TestGenerator_post_process_test_content(self, content: str) -&gt; None:
    result = hypot_test_gen.TestGenerator.post_process_test_content(self=self, content=content)
    repeat = hypot_test_gen.TestGenerator.post_process_test_content(self=result, content=content)
    self.assertEqual(result, repeat)
</code></pre></div>
<h1 id="-test_add_to_sys_path_basicpy-_1">----- test_add_to_sys_path_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzAdd_To_Sys_Path(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(path=st.text(), description=st.text())
def test_fuzz_add_to_sys_path(self, path: str, description: str) -&gt; None:
    hypot_test_gen.add_to_sys_path(path=path, description=description)
</code></pre></div>
<h1 id="-test_testgenerator_generate_method_variants_errorspy-_1">----- test_TestGenerator_generate_method_variants_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorgenerate_Method_Variants(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())))
def test_fuzz_TestGenerator_generate_method_variants(self, entity: hypot_test_gen.TestableEntity) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.generate_method_variants(self=self, entity=entity)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_parse_ast_errorspy-_1">----- test_TestGenerator_parse_ast_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorparse_Ast(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), content=st.text())
def test_fuzz_TestGenerator_parse_ast(self, content: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.parse_ast(self=self, content=content)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_moduleparser_store_class_bases_basicpy-_1">----- test_ModuleParser_store_class_bases_basic.py -----</h1>
<p>import ast
import hypot_test_gen
import unittest
from ast import ClassDef
from hypothesis import given, strategies as st</p>
<p>class TestFuzzModuleparserstore_Class_Bases(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), node=st.builds(ClassDef))
def test_fuzz_ModuleParser_store_class_bases(self, node: ast.ClassDef) -&gt; None:
    hypot_test_gen.ModuleParser.store_class_bases(self=self, node=node)
</code></pre></div>
<h1 id="-test_testgenerator_log_entities_summary_basicpy-_1">----- test_TestGenerator_log_entities_summary_basic.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorlog_Entities_Summary(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entities=st.lists(st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text()))))
def test_fuzz_TestGenerator_log_entities_summary(self, entities: typing.List[hypot_test_gen.TestableEntity]) -&gt; None:
    hypot_test_gen.TestGenerator.log_entities_summary(self=self, entities=entities)
</code></pre></div>
<h1 id="-test_testgenerator_handle_failed_attempt_errorspy-_1">----- test_TestGenerator_handle_failed_attempt_errors.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorhandle_Failed_Attempt(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())), variant=st.dictionaries(keys=st.text(), values=st.text()), attempt=st.integers())
def test_fuzz_TestGenerator_handle_failed_attempt(self, entity: hypot_test_gen.TestableEntity, variant: typing.Dict[str, str], attempt: int) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.handle_failed_attempt(self=self, entity=entity, variant=variant, attempt=attempt)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_add_to_sys_path_binary-oppy-_1">----- test_add_to_sys_path_binary-op.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestBinaryOperationadd_to_sys_path(unittest.TestCase):
    add_to_sys_path_operands = st.text()</p>
<div class="highlight"><pre><span></span><code>@given(a=add_to_sys_path_operands, b=add_to_sys_path_operands, c=add_to_sys_path_operands)
def test_associative_binary_operation_add_to_sys_path(self, a, b, c) -&gt; None:
    left = hypot_test_gen.add_to_sys_path(path=a, description=hypot_test_gen.add_to_sys_path(path=b, description=c))
    right = hypot_test_gen.add_to_sys_path(path=hypot_test_gen.add_to_sys_path(path=a, description=b), description=c)
    self.assertEqual(left, right)

@given(a=add_to_sys_path_operands, b=add_to_sys_path_operands)
def test_commutative_binary_operation_add_to_sys_path(self, a, b) -&gt; None:
    left = hypot_test_gen.add_to_sys_path(path=a, description=b)
    right = hypot_test_gen.add_to_sys_path(path=b, description=a)
    self.assertEqual(left, right)

@given(a=add_to_sys_path_operands)
def test_identity_binary_operation_add_to_sys_path(self, a) -&gt; None:
    identity = &#39;&#39;
    self.assertEqual(a, hypot_test_gen.add_to_sys_path(path=a, description=identity))
    self.assertEqual(a, hypot_test_gen.add_to_sys_path(path=identity, description=a))
</code></pre></div>
<h1 id="-test_testgenerator_pre_run_cleanup_basicpy-_1">----- test_TestGenerator_pre_run_cleanup_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorpre_Run_Cleanup(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_pre_run_cleanup(self) -&gt; None:
    hypot_test_gen.TestGenerator.pre_run_cleanup(self=self)
</code></pre></div>
<h1 id="-test_testgenerator_populate_entities_errorspy-_1">----- test_TestGenerator_populate_entities_errors.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypot_test_gen import ModuleParser
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorpopulate_Entities(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), parser=st.builds(ModuleParser), module_path=st.text())
def test_fuzz_TestGenerator_populate_entities(self, parser: hypot_test_gen.ModuleParser, module_path: str) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.populate_entities(self=self, parser=parser, module_path=module_path)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<h1 id="-test_testgenerator_log_environment_basicpy-_1">----- test_TestGenerator_log_environment_basic.py -----</h1>
<p>import hypot_test_gen
import unittest
from hypothesis import given, strategies as st</p>
<p>class TestFuzzTestgeneratorlog_Environment(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing())
def test_fuzz_TestGenerator_log_environment(self) -&gt; None:
    hypot_test_gen.TestGenerator.log_environment(self=self)
</code></pre></div>
<h1 id="-test_testgenerator_attempt_test_generation_errorspy-_1">----- test_TestGenerator_attempt_test_generation_errors.py -----</h1>
<p>import hypot_test_gen
import typing
import unittest
from hypot_test_gen import TestableEntity
from hypothesis import given, reject, strategies as st</p>
<p>class TestFuzzTestgeneratorattempt_Test_Generation(unittest.TestCase):</p>
<div class="highlight"><pre><span></span><code>@given(self=st.nothing(), entity=st.builds(TestableEntity, entity_type=st.sampled_from([&#39;instance_method&#39;, &#39;function&#39;, &#39;method&#39;, &#39;class&#39;]), module_path=st.text(), name=st.text(), parent_class=st.one_of(st.none(), st.none(), st.text())), variant=st.dictionaries(keys=st.text(), values=st.text()), attempt=st.integers())
def test_fuzz_TestGenerator_attempt_test_generation(self, entity: hypot_test_gen.TestableEntity, variant: typing.Dict[str, str], attempt: int) -&gt; None:
    try:
        hypot_test_gen.TestGenerator.attempt_test_generation(self=self, entity=entity, variant=variant, attempt=attempt)
    except (TypeError, ValueError):
        reject()
</code></pre></div>
<p>is the content of your automatically generated Python test files (potentially multiple files content combined or listed).
       import ast
import logging
import os
import subprocess
import sys
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union, Literal, Any</p>
<p>import snoop  # type: ignore</p>
<h1 id="removed-unused-from-hypothesis-import-strategies-as-st_1">Removed unused: from hypothesis import strategies as st</h1>
<p>import importlib.util  # For dynamic imports</p>
<h1 id="set-up-logging-with-file-and-console-output_1">Set up logging with file and console output</h1>
<p>log_file = "test_generator_debug.log"
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.FileHandler(log_file), logging.StreamHandler()],
)
logger = logging.getLogger(<strong>name</strong>)</p>
<h1 id="well-assume-the-prompt_templatemd-is-in-the-same-directory-as-this-script_1">We'll assume the prompt_template.md is in the same directory as this script</h1>
<p>PROMPT_TEMPLATE_FILE = Path(<strong>file</strong>).parent / "prompt_template.md"</p>
<p>def load_text_prompt_template() -&gt; str:
    """
    Load the text prompt template from the prompt_template.md file.
    """
    try:
        return PROMPT_TEMPLATE_FILE.read_text(encoding="utf-8")
    except FileNotFoundError:
        logger.error("prompt_template.md not found. Please ensure it is in the same directory.")
        return ""</p>
<h1 id="configure-snoop-to-write-to-a-separate-debug-log_1">Configure snoop to write to a separate debug log</h1>
<p>snoop.install(out=Path("snoop_debug.log"))</p>
<p>def fix_leading_zeros(test_code: str) -&gt; str:
    """
    Replace decimal integers with leading zeros (except a standalone "0") with their corrected form.
    For example, "007" becomes "7" and "-0123" becomes "-123".
    """
    import re
    # Use a regex with negative lookbehind and lookahead to match numbers that start with one or more zeros.
    # The pattern (?&lt;!\d)(-?)0+(\d+)(?!\d) ensures that a minus sign is captured if present,
    # and that only isolated numbers are matched.
    fixed_code = re.sub(r'(?&lt;!\d)(-?)0+(\d+)(?!\d)', lambda m: m.group(1) + str(int(m.group(2))), test_code)
    return fixed_code</p>
<p>def remove_logger_lines(text: str) -&gt; str:
    """
    Remove extraneous logging lines from the generated test content.
    This function filters out:
      - Lines starting with a bracketed or non-bracketed timestamp (e.g. "[2025-3-27 14:55:48,330] ..." or "2025-03-27 14:55:48,330 - ...").
      - Lines containing known noisy substrings such as 'real_accelerator.py:' or 'Setting ds_accelerator to'.
    """
    import re
    lines = text.splitlines()
    filtered = []
    timestamp_pattern = re.compile(r'^[?\d{4}-\d{1,2}-\d{1,2}')
    for line in lines:
        # Skip lines matching a leading timestamp
        if timestamp_pattern.match(line):
            continue
        # Skip lines containing known noisy substrings
        if 'real_accelerator.py:' in line or 'Setting ds_accelerator to' in line:
            continue
        filtered.append(line)
    return "\n".join(filtered).strip()</p>
<p>@dataclass
class TestableEntity:
    """Represents a class, method, or function that can be tested"""
    name: str
    module_path: str
    entity_type: Literal['class', 'method', 'function', 'instance_method']  # More restrictive type
    parent_class: Optional[str] = None</p>
<p>def fix_pythonpath(file_path: Path) -&gt; None:
    """Ensure the module being tested is in Python's path"""
    parent_dir = str(file_path.parent.absolute())
    add_to_sys_path(parent_dir, "parent directory")</p>
<div class="highlight"><pre><span></span><code>if &quot;src&quot; in file_path.parts:
    src_path = construct_src_path(file_path)
    add_to_sys_path(src_path, &quot;src directory&quot;)
</code></pre></div>
<p>def add_to_sys_path(path: str, description: str) -&gt; None:
    """Helper function to add a path to sys.path if not already present"""
    if path not in sys.path:
        sys.path.insert(0, path)
        logger.debug(f"Added {description} to sys.path: {path}")</p>
<p>def construct_src_path(file_path: Path) -&gt; str:
    """Construct the src path from the file path"""
    src_index = file_path.parts.index("src")
    src_path = str(Path(*file_path.parts[: src_index + 1]).absolute())
    return src_path</p>
<p>class ModuleParser(ast.NodeVisitor):
    """AST-based parser for Python modules"""</p>
<div class="highlight"><pre><span></span><code>def __init__(self):
    self.entities: List[TestableEntity] = []
    self.current_class: Optional[str] = None
    self.class_bases: Dict[str, List[str]] = {}

def visit_ClassDef(self, node: ast.ClassDef) -&gt; None:
    if node.name.startswith(&quot;_&quot;):
        return
    self.store_class_bases(node)
    self.add_class_entity(node)
    self.process_class_contents(node)

def store_class_bases(self, node: ast.ClassDef) -&gt; None:
    &quot;&quot;&quot;Store base classes for inheritance checking&quot;&quot;&quot;
    bases = []
    for base in node.bases:
        base_name = self.get_base_name(base)
        if base_name:
            bases.append(base_name)
    self.class_bases[node.name] = bases
    logger.debug(f&quot;Stored bases for class {node.name}: {bases}&quot;)

def get_base_name(self, base: ast.AST) -&gt; Optional[str]:
    &quot;&quot;&quot;Retrieve the base class name from the AST node&quot;&quot;&quot;
    if isinstance(base, ast.Name):
        return base.id
    elif isinstance(base, ast.Attribute):
        if isinstance(base.value, ast.Name):
            return f&quot;{base.value.id}.{base.attr}&quot;
    return None

def add_class_entity(self, node: ast.ClassDef) -&gt; None:
    &quot;&quot;&quot;Add the class itself to entities&quot;&quot;&quot;
    self.entities.append(TestableEntity(node.name, &quot;&quot;, &quot;class&quot;))
    logger.debug(f&quot;Added class entity: {node.name}&quot;)

def process_class_contents(self, node: ast.ClassDef) -&gt; None:
    &quot;&quot;&quot;Process the contents of the class&quot;&quot;&quot;
    old_class = self.current_class
    self.current_class = node.name
    self.generic_visit(node)
    self.current_class = old_class
    logger.debug(f&quot;Processed contents of class {node.name}&quot;)

def visit_FunctionDef(self, node: ast.FunctionDef) -&gt; None:
    if node.name.startswith(&quot;_&quot;):
        return
    if self.current_class:
        self.process_method(node)
    else:
        self.add_function_entity(node)

def process_method(self, node: ast.FunctionDef) -&gt; None:
    &quot;&quot;&quot;Process a method within a class&quot;&quot;&quot;
    if self.should_skip_method(node):
        return

    is_instance_method = self.determine_instance_method(node)
    entity_type = &quot;instance_method&quot; if is_instance_method else &quot;method&quot;

    # The method path should include the class
    method_name = f&quot;{self.current_class}.{node.name}&quot; if self.current_class else node.name

    self.entities.append(
        TestableEntity(
            name=node.name,
            module_path=&quot;&quot;,
            entity_type=entity_type,
            parent_class=self.current_class,
        )
    )
    logger.debug(
        f&quot;Added {&#39;instance_method&#39; if is_instance_method else &#39;method&#39;} entity: {method_name}&quot;
    )

def determine_instance_method(self, node: ast.FunctionDef) -&gt; bool:
    &quot;&quot;&quot;Determine if the method is an instance method&quot;&quot;&quot;
    for decorator in node.decorator_list:
        if isinstance(decorator, ast.Name) and decorator.id in {&quot;classmethod&quot;, &quot;staticmethod&quot;}:
            return False
    return True

def should_skip_method(self, node: ast.FunctionDef) -&gt; bool:
    &quot;&quot;&quot;Determine if the method should be skipped based on inheritance or naming&quot;&quot;&quot;
    current_bases = self.class_bases.get(self.current_class, [])
    if any(base in {&quot;NodeVisitor&quot;, &quot;ast.NodeVisitor&quot;} for base in current_bases):
        if node.name.startswith(&quot;visit_&quot;):
            logger.debug(f&quot;Skipping inherited visit method: {node.name}&quot;)
            return True
    if node.name in {&quot;__init__&quot;, &quot;__str__&quot;, &quot;__repr__&quot;, &quot;property&quot;}:
        logger.debug(f&quot;Skipping magic or property method: {node.name}&quot;)
        return True
    return False

def add_function_entity(self, node: ast.FunctionDef) -&gt; None:
    &quot;&quot;&quot;Add a standalone function to entities&quot;&quot;&quot;
    self.entities.append(TestableEntity(node.name, &quot;&quot;, &quot;function&quot;))
    logger.debug(f&quot;Added function entity: {node.name}&quot;)
</code></pre></div>
<p>def debug_command_output(cmd: str, stdout: str, stderr: str, returncode: int) -&gt; None:
    """Helper function to debug command execution"""
    logger.debug("Command execution details:")
    logger.debug(f"Command: {cmd}")
    logger.debug(f"Return code: {returncode}")
    logger.debug(f"stdout length: {len(stdout)}")
    logger.debug(f"stderr length: {len(stderr)}")
    logger.debug("First 1000 chars of stdout:")
    logger.debug(stdout[:1000])
    logger.debug("First 1000 chars of stderr:")
    logger.debug(stderr[:1000])</p>
<p>class TestFixer(ast.NodeTransformer):
    """AST transformer to fix duplicate self parameters"""</p>
<div class="highlight"><pre><span></span><code>def visit_FunctionDef(self, node: ast.FunctionDef) -&gt; ast.FunctionDef:
    seen_self = False
    new_args = []

    for arg in node.args.args:
        if arg.arg == &#39;self&#39;:
            if not seen_self:
                seen_self = True
                new_args.append(arg)
        else:
            new_args.append(arg)

    node.args.args = new_args
    return node
</code></pre></div>
<p>def fix_duplicate_self(test_content: str) -&gt; Optional[str]:
    """
    Fix duplicate self parameters in test content.</p>
<div class="highlight"><pre><span></span><code>Args:
    test_content: String containing the test code

Returns:
    Fixed test code string, or None if parsing fails
&quot;&quot;&quot;
try:
    tree = ast.parse(test_content)

    fixer = TestFixer()
    fixed_tree = fixer.visit(tree)

    try:
        return ast.unparse(fixed_tree)
    except AttributeError:
        import astunparse
        return astunparse.unparse(fixed_tree)

except Exception as e:
    print(f&quot;Error fixing test content: {e}&quot;)
    return None
</code></pre></div>
<p>class TestGenerator:
    """Manages generation of Hypothesis tests for Python modules"""
    def wrap_with_prompt(self, combined_test_code: str, original_source_code: str) -&gt; str:
        """
        Wrap the combined test code and original source code in the custom text prompt
        read from 'prompt_template.md'.
        """
        prompt_template = load_text_prompt_template()
        return prompt_template.format(
            TEST_CODE=combined_test_code,
            FULL_SRC_CODE=original_source_code
        )</p>
<div class="highlight"><pre><span></span><code>def pre_run_cleanup(self) -&gt; None:
    &quot;&quot;&quot;
    Remove any leftover combined test files (matching &#39;test_hyp_*.py&#39;) from previous runs.
    This ensures we don&#39;t mix old combined files with new runs.
    &quot;&quot;&quot;
    leftover_files = list(self.output_dir.glob(&quot;test_hyp_*.py&quot;))
    for leftover in leftover_files:
        try:
            leftover.unlink()
            logger.debug(f&quot;Removed leftover combined file: {leftover.name}&quot;)
        except Exception as e:
            logger.error(f&quot;Failed to delete leftover file {leftover.name}: {e}&quot;)

def __init__(self, output_dir: Path = Path(&quot;generated_tests&quot;)):
    self.output_dir = output_dir
    self.output_dir.mkdir(exist_ok=True)
    self.verify_output_dir()

def verify_output_dir(self) -&gt; None:
    &quot;&quot;&quot;Verify that the output directory exists and is writable&quot;&quot;&quot;
    logger.debug(f&quot;Test generator initialized with output dir: {self.output_dir}&quot;)
    logger.debug(f&quot;Output dir exists: {self.output_dir.exists()}&quot;)
    logger.debug(f&quot;Output dir is writable: {os.access(self.output_dir, os.W_OK)}&quot;)

def run_hypothesis_write(self, command: str) -&gt; Optional[str]:
    &quot;&quot;&quot;Execute hypothesis write command and return output if successful&quot;&quot;&quot;
    full_cmd = f&quot;hypothesis write {command}&quot;
    logger.debug(f&quot;Executing hypothesis command: {full_cmd}&quot;)

    try:
        self.log_environment()
        env = self.prepare_environment()

        result = subprocess.run(
            full_cmd, shell=True, capture_output=True, text=True, env=env
        )

        debug_command_output(
            full_cmd, result.stdout, result.stderr, result.returncode
        )

        return self.process_hypothesis_result(result)

    except Exception as e:
        logger.error(f&quot;Error running hypothesis: {e}&quot;, exc_info=True)
        return None

def log_environment(self) -&gt; None:
    &quot;&quot;&quot;Log the current environment settings&quot;&quot;&quot;
    logger.debug(f&quot;PYTHONPATH before modification: {os.getenv(&#39;PYTHONPATH&#39;)}&quot;)
    logger.debug(f&quot;sys.path: {sys.path}&quot;)
    logger.debug(f&quot;Current working directory: {os.getcwd()}&quot;)

def prepare_environment(self) -&gt; Dict[str, str]:
    &quot;&quot;&quot;Prepare the environment variables for subprocess&quot;&quot;&quot;
    env = os.environ.copy()
    env[&quot;PYTHONPATH&quot;] = &quot;:&quot;.join(sys.path)
    env.setdefault(&quot;PYTHONIOENCODING&quot;, &quot;utf-8&quot;)
    return env

def process_hypothesis_result(self, result: subprocess.CompletedProcess) -&gt; Optional[str]:
    &quot;&quot;&quot;Process the result of the hypothesis command&quot;&quot;&quot;
    if result.returncode == 0 and result.stdout:
        content = result.stdout.strip()

        # Remove extraneous logging lines first
        content = remove_logger_lines(content)

        if not content or len(content) &lt; 50:
            logger.warning(&quot;Hypothesis generated insufficient content&quot;)
            return None

        # Process and fix the test content using post_process_test_content
        fixed_content = self.post_process_test_content(content)
        if fixed_content is None:
            logger.warning(&quot;Failed to process test content&quot;)
            return None

        logger.info(&quot;Successfully generated and processed test content&quot;)
        return fixed_content

    if result.stderr and not self.is_known_error(result.stderr):
        logger.warning(f&quot;Command failed: {result.stderr}&quot;)
    return None

def post_process_test_content(self, content: str) -&gt; Optional[str]:
    &quot;&quot;&quot;Post-process generated test content&quot;&quot;&quot;
    try:
        # Also remove extraneous logger lines (defensive)
        content = remove_logger_lines(content)

        # First, fix any leading zeros in integer literals
        content = fix_leading_zeros(content)
        # Then, fix duplicate self parameters
        fixed_content = fix_duplicate_self(content)
        if fixed_content is None:
            logger.warning(&quot;Failed to fix duplicate self parameters.&quot;)
            return content
        return fixed_content
    except Exception as e:
        logger.error(f&quot;Error processing test content: {e}&quot;, exc_info=True)
        return None

def is_known_error(self, stderr: str) -&gt; bool:
    &quot;&quot;&quot;Check if the stderr contains known non-critical errors&quot;&quot;&quot;
    known_errors = [
        &quot;InvalidArgument: Got non-callable&quot;,
        &quot;Could not resolve&quot;,
        &quot;but it doesn&#39;t have a&quot;,
    ]
    return any(msg in stderr for msg in known_errors)

def try_generate_test(
    self, entity: TestableEntity, variant: Dict[str, str], max_retries: int = 3
) -&gt; bool:
    &quot;&quot;&quot;Attempt to generate a specific test variant with retries&quot;&quot;&quot;
    for attempt in range(1, max_retries + 1):
        logger.debug(
            f&quot;Attempt {attempt} for {variant[&#39;type&#39;]} test on {entity.name}&quot;
        )
        output = self.attempt_test_generation(entity, variant, attempt)
        if output:
            return True
    return False

def attempt_test_generation(
    self, entity: TestableEntity, variant: Dict[str, str], attempt: int
) -&gt; Optional[bool]:
    &quot;&quot;&quot;Attempt a single test generation&quot;&quot;&quot;
    output = self.run_hypothesis_write(variant[&quot;cmd&quot;])
    if output:
        return self.handle_generated_output(entity, variant, output)
    else:
        return self.handle_failed_attempt(entity, variant, attempt)

def handle_generated_output(
    self, entity: TestableEntity, variant: Dict[str, str], output: str
) -&gt; bool:
    &quot;&quot;&quot;Handle the output from a successful hypothesis generation&quot;&quot;&quot;
    name_prefix = (
        f&quot;{entity.parent_class}_{entity.name}&quot;
        if entity.parent_class
        else entity.name
    )
    output_file = self.output_dir / f&quot;test_{name_prefix}_{variant[&#39;type&#39;]}.py&quot;

    try:
        self.write_and_verify_output(output_file, output)
        logger.info(f&quot;Successfully generated test at {output_file}&quot;)
        print(f&quot;Generated {variant[&#39;type&#39;]} test: {output_file}&quot;)
        return True
    except Exception as e:
        logger.error(f&quot;Error writing test file: {e}&quot;, exc_info=True)
        return False

def write_and_verify_output(self, output_file: Path, content: str) -&gt; None:
    &quot;&quot;&quot;Write the test content to a file and verify its integrity&quot;&quot;&quot;
    logger.debug(&quot;Test content details:&quot;)
    logger.debug(f&quot;Content length: {len(content)}&quot;)
    logger.debug(f&quot;Content preview:\n{content[:1000]}&quot;)
    logger.debug(f&quot;Writing to file: {output_file}&quot;)

    output_file.write_text(content)

    written_content = output_file.read_text()
    if not written_content:
        logger.error(f&quot;File {output_file} is empty after writing!&quot;)
        raise ValueError(f&quot;Empty file: {output_file}&quot;)

    if written_content != content:
        logger.error(&quot;Written content doesn&#39;t match original content!&quot;)
        logger.debug(f&quot;Original length: {len(content)}&quot;)
        logger.debug(f&quot;Written length: {len(written_content)}&quot;)
        raise ValueError(&quot;Content mismatch after writing&quot;)

    logger.debug(f&quot;Final file size: {output_file.stat().st_size} bytes&quot;)

def handle_failed_attempt(
    self, entity: TestableEntity, variant: Dict[str, str], attempt: int
) -&gt; Optional[bool]:
    &quot;&quot;&quot;Handle a failed test generation attempt&quot;&quot;&quot;
    if attempt &lt; 3:
        logger.warning(f&quot;Attempt {attempt} failed, retrying...&quot;)
        time.sleep(1)
    else:
        logger.error(f&quot;All attempts failed for {entity.name}&quot;)
    return None

def get_module_contents(self, file_path: Path) -&gt; Tuple[str, List[TestableEntity]]:
    &quot;&quot;&quot;Extract module path and testable entities using AST parsing&quot;&quot;&quot;
    logger.debug(f&quot;Reading file: {file_path}&quot;)
    try:
        module_path = self.construct_module_path(file_path)
        content = file_path.read_text()
        parser = self.parse_ast(content)
        imports = self.extract_imports(content)

        entities = self.populate_entities(parser, module_path)
        self.log_entities_summary(entities)
        return module_path, entities

    except Exception as e:
        logger.error(f&quot;Error parsing module contents: {e}&quot;, exc_info=True)
        raise

def construct_module_path(self, file_path: Path) -&gt; str:
    &quot;&quot;&quot;Construct the module path from the file path&quot;&quot;&quot;
    parts = file_path.parts
    if &quot;src&quot; in parts:
        src_index = parts.index(&quot;src&quot;)
        module_parts = list(parts[src_index + 1 :])
    else:
        module_parts = [file_path.stem]
    module_path = &quot;.&quot;.join([p.replace(&quot;.py&quot;, &quot;&quot;) for p in module_parts])
    logger.debug(f&quot;Constructed module path: {module_path}&quot;)
    return module_path

def parse_ast(self, content: str) -&gt; ModuleParser:
    &quot;&quot;&quot;Parse the AST of the given content&quot;&quot;&quot;
    tree = ast.parse(content)
    parser = ModuleParser()
    parser.visit(tree)
    return parser

def extract_imports(self, content: str) -&gt; set:
    &quot;&quot;&quot;Extract import statements from the content&quot;&quot;&quot;
    tree = ast.parse(content)
    imports = set()
    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            for name in node.names:
                imports.add(name.name)
        elif isinstance(node, ast.ImportFrom):
            if node.module:
                imports.add(node.module)
    logger.debug(f&quot;Found imports: {imports}&quot;)
    return imports

def populate_entities(self, parser: ModuleParser, module_path: str) -&gt; List[TestableEntity]:
    &quot;&quot;&quot;Populate entities with correct module paths&quot;&quot;&quot;
    entities = []
    for entity in parser.entities:
        entity.module_path = module_path
        entities.append(entity)
    return entities

def log_entities_summary(self, entities: List[TestableEntity]) -&gt; None:
    &quot;&quot;&quot;Log a summary of found entities&quot;&quot;&quot;
    classes = sum(1 for e in entities if e.entity_type == &quot;class&quot;)
    methods = sum(
        1 for e in entities if e.entity_type in {&quot;method&quot;, &quot;instance_method&quot;}
    )
    functions = sum(1 for e in entities if e.entity_type == &quot;function&quot;)
    logger.info(
        f&quot;Found {classes} classes, {methods} methods, and {functions} functions&quot;
    )

def generate_all_tests(self, file_path: Path) -&gt; None:
    &quot;&quot;&quot;Generate all possible test variants for a Python file&quot;&quot;&quot;
    logger.info(f&quot;Generating tests for file: {file_path}&quot;)
    try:
        fix_pythonpath(file_path)
        module_path, entities = self.get_module_contents(file_path)
        self.display_module_info(module_path, entities)
        total_variants = sum(len(self.generate_test_variants(e)) for e in entities)
        self.process_entities(entities, total_variants, module_path)
        print()
        self.combine_and_cleanup_tests(file_path)
    except Exception:
        logger.error(&quot;Test generation failed&quot;, exc_info=True)
        raise

def display_module_info(self, module_path: str, entities: List[TestableEntity]) -&gt; None:
    &quot;&quot;&quot;Display information about the module and its entities&quot;&quot;&quot;
    print(f&quot;\nProcessing module: {module_path}&quot;)
    print(
        f&quot;Found {len([e for e in entities if e.entity_type == &#39;class&#39;])} classes, &quot;
        f&quot;{len([e for e in entities if e.entity_type in {&#39;method&#39;, &#39;instance_method&#39;}])} methods, and &quot;
        f&quot;{len([e for e in entities if e.entity_type == &#39;function&#39;])} functions&quot;
    )

def process_entities(self, entities: List[TestableEntity], total_variants: int, module_path: str) -&gt; None:
    &quot;&quot;&quot;Process each entity and generate tests&quot;&quot;&quot;
    current = 0
    for entity in entities:
        print(f&quot;\nGenerating tests for: {module_path}.{entity.name}&quot;)
        variants = self.generate_test_variants(entity)
        for variant in variants:
            current += 1
            print(f&quot;\rGenerating tests: [{current}/{total_variants}]&quot;, end=&quot;&quot;)
            self.try_generate_test(entity, variant)
    print()

def _get_object(self, path: str) -&gt; Optional[Any]:
    &quot;&quot;&quot;Get the actual object from its module path&quot;&quot;&quot;
    try:
        module_parts = path.split(&#39;.&#39;)
        module_path = &#39;.&#39;.join(module_parts[:-1])
        obj_name = module_parts[-1]

        spec = importlib.util.find_spec(module_path)
        if spec and spec.loader:
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            return getattr(module, obj_name, None)
    except Exception:
        return None

def generate_method_variants(self, entity: TestableEntity) -&gt; List[Dict[str, str]]:
    &quot;&quot;&quot;Generate test variants for methods and instance methods&quot;&quot;&quot;
    if entity.entity_type in {&quot;method&quot;, &quot;instance_method&quot;}:
        method_path = f&quot;{entity.module_path}.{entity.parent_class}.{entity.name}&quot;
    else:
        method_path = f&quot;{entity.module_path}.{entity.name}&quot;

    # Start with basic test with type inference
    variants = [
        self.create_variant(
            &quot;basic&quot;,
            f&quot;--style=unittest --annotate {method_path}&quot;
        )
    ]

    # Add error variant
    variants.append(
        self.create_variant(
            &quot;errors&quot;,
            f&quot;--style=unittest --annotate --except ValueError --except TypeError {method_path}&quot;
        )
    )

    # Add special variants based on method name
    name = entity.name.lower()
    variants.extend(self._generate_special_variants(name, method_path))

    return variants

def _generate_special_variants(self, name: str, method_path: str) -&gt; List[Dict[str, str]]:
    &quot;&quot;&quot;Generate special variants based on method name&quot;&quot;&quot;
    special_variants = []

    if any(x in name for x in [&quot;transform&quot;, &quot;convert&quot;, &quot;process&quot;, &quot;format&quot;]):
        special_variants.append(
            self.create_variant(
                &quot;idempotent&quot;,
                f&quot;--style=unittest --annotate --idempotent {method_path}&quot;
            )
        )

    if any(x in name for x in [&quot;validate&quot;, &quot;verify&quot;, &quot;check&quot;, &quot;assert&quot;]):
        special_variants.append(
            self.create_variant(
                &quot;validation&quot;,
                f&quot;--style=unittest --annotate --errors-equivalent {method_path}&quot;
            )
        )

    if &quot;encode&quot; in name or &quot;decode&quot; in name:
        special_variants.append(
            self.create_variant(
                &quot;roundtrip&quot;,
                f&quot;--style=unittest --annotate --roundtrip {method_path}&quot;
            )
        )

    if any(x in name for x in [&quot;add&quot;, &quot;multiply&quot;, &quot;subtract&quot;, &quot;combine&quot;, &quot;merge&quot;]):
        special_variants.append(
            self.create_variant(
                &quot;binary-op&quot;,
                f&quot;--style=unittest --annotate --binary-op {method_path}&quot;
            )
        )

    return special_variants

def generate_function_variants(self, entity: TestableEntity) -&gt; List[Dict[str, str]]:
    &quot;&quot;&quot;Generate test variants for standalone functions&quot;&quot;&quot;
    base_cmd = f&quot;--style=unittest --annotate {entity.module_path}.{entity.name}&quot;
    variants = [self.create_variant(&quot;basic&quot;, base_cmd)]

    # Add special variants for functions if needed
    name = entity.name.lower()
    if &quot;encode&quot; in name or &quot;decode&quot; in name or &quot;serialize&quot; in name or &quot;deserialize&quot; in name:
        variants.append(self.create_variant(&quot;roundtrip&quot;, f&quot;{base_cmd} --roundtrip&quot;))
    elif any(x in name for x in [&quot;add&quot;, &quot;sub&quot;, &quot;mul&quot;, &quot;combine&quot;, &quot;merge&quot;]):
        variants.append(self.create_variant(&quot;binary-op&quot;, f&quot;{base_cmd} --binary-op&quot;))

    return variants

def generate_test_variants(self, entity: TestableEntity) -&gt; List[Dict[str, str]]:
    &quot;&quot;&quot;Generate all applicable test variants for an entity&quot;&quot;&quot;
    variants = []
    if entity.entity_type == &quot;class&quot;:
        # For classes, just a basic annotated variant
        variants.append(self.create_variant(&quot;basic&quot;, f&quot;--style=unittest --annotate {entity.module_path}.{entity.name}&quot;))
    elif entity.entity_type in {&quot;method&quot;, &quot;instance_method&quot;}:
        variants.extend(self.generate_method_variants(entity))
    else:
        variants.extend(self.generate_function_variants(entity))
    logger.debug(f&quot;Generated variants for {entity.name}: {[v[&#39;type&#39;] for v in variants]}&quot;)
    return variants

def create_variant(self, variant_type: str, cmd: str) -&gt; Dict[str, str]:
    &quot;&quot;&quot;Create a test variant dictionary with properly formatted command&quot;&quot;&quot;
    return {
        &quot;type&quot;: variant_type,
        &quot;cmd&quot;: cmd.strip()  # Ensure no extra whitespace in command
    }

def combine_and_cleanup_tests(self, file_path: Path) -&gt; None:
    &quot;&quot;&quot;
    Combines individual test files into a single file and deletes the originals,
    then removes the combined .py file so only the final markdown remains.

    Args:
        file_path (Path): The original Python file used for test generation.
    &quot;&quot;&quot;
    # Step 1: Derive the combined file name from the original file
    original_stem = file_path.stem  # e.g., &quot;my_module&quot;
    combined_filename = f&quot;test_hyp_{original_stem}.py&quot;
    combined_filepath = self.output_dir / combined_filename

    # Step 2: Collect all generated test files in the output directory
    # Using &quot;test_*.py&quot; so that it naturally ignores any leftover .md files
    test_files = list(self.output_dir.glob(&quot;test_*.py&quot;))

    # Step 3: Combine contents of each test file into a single string
    combined_content = &quot;&quot;
    for test_file in test_files:
        content = test_file.read_text()
        separator = f&quot;\n# ----- {test_file.name} -----\n&quot;
        combined_content += separator + content + &quot;\n&quot;

    # Step 4: Write the combined content to the new file
    combined_filepath.write_text(combined_content)

    # Step 5: Wrap the combined test code with the prompt to produce the final Markdown
    original_source_code = file_path.read_text()
    final_wrapped_content = self.wrap_with_prompt(combined_content, original_source_code)
    final_wrapped_file = self.output_dir / f&quot;test_wrapped_{original_stem}.md&quot;
    final_wrapped_file.write_text(final_wrapped_content)
    logger.info(f&quot;Final wrapped test file created at {final_wrapped_file}&quot;)

    # Optional: verify the combined file
    if not combined_filepath.exists() or len(combined_filepath.read_text()) &lt; 50:
        logger.error(f&quot;Combined test file {combined_filepath} appears to be incomplete.&quot;)
        return

    # Step 6: Cleanup - delete individual test files
    for test_file in test_files:
        try:
            test_file.unlink()
            logger.debug(f&quot;Deleted individual test file: {test_file.name}&quot;)
        except Exception as e:
            logger.error(f&quot;Failed to delete {test_file.name}: {e}&quot;)

    # Step 7: Logging and feedback
    logger.info(f&quot;Combined {len(test_files)} test files into {combined_filename} and removed originals.&quot;)

    # Step 8: Apply Ruff cleaning commands to the combined file
    cmds = [
        f&quot;ruff check {combined_filepath}&quot;,
        f&quot;ruff check --fix {combined_filepath}&quot;,
        f&quot;ruff format {combined_filepath}&quot;,
        f&quot;ruff check --select I --fix {combined_filepath}&quot;,
        f&quot;ruff format {combined_filepath}&quot;
    ]
    for cmd in cmds:
        try:
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            if result.returncode != 0:
                logger.error(f&quot;Ruff command &#39;{cmd}&#39; failed: {result.stderr}&quot;)
            else:
                logger.info(f&quot;Ruff command &#39;{cmd}&#39; succeeded: {result.stdout}&quot;)
        except Exception as e:
            logger.error(f&quot;Failed to run ruff command &#39;{cmd}&#39;: {e}&quot;)

    # Finally, remove the combined .py file so only the markdown remains
    if combined_filepath.exists():
        combined_filepath.unlink()
        logger.info(f&quot;Deleted the combined file {combined_filepath} so that only the Markdown file remains.&quot;)
</code></pre></div>
<p>def parse_args(args: Optional[list] = None) -&gt; Path:
    """
    Parse command line arguments and validate file path.</p>
<div class="highlight"><pre><span></span><code>Args:
    args: Optional list of command line arguments. If None, uses sys.argv[1:]

Returns:
    Path object for the input file

Raises:
    ValueError: If arguments are invalid or file doesn&#39;t exist
&quot;&quot;&quot;
if args is None:
    args = sys.argv[1:]

if len(args) != 1:
    raise ValueError(&quot;Exactly one argument (path to Python file) required&quot;)

file_path = Path(args[0])
if not file_path.exists() or not file_path.is_file():
    raise ValueError(f&quot;File does not exist or is not a file: {file_path}&quot;)

return file_path
</code></pre></div>
<p>def run_test_generation(file_path: Union[str, Path]) -&gt; bool:
    """
    Run the test generation process for a given file.
    Now also calls pre_run_cleanup before generate_all_tests.</p>
<div class="highlight"><pre><span></span><code>Args:
    file_path: Path to the Python file to generate tests for

Returns:
    bool: True if test generation was successful, False otherwise

Raises:
    Exception: If test generation fails
&quot;&quot;&quot;
try:
    if isinstance(file_path, str):
        file_path = Path(file_path)

    logger.info(f&quot;Starting test generator for {file_path}&quot;)
    generator = TestGenerator()

    # Clean up any leftover combined files from prior runs
    generator.pre_run_cleanup()

    # Proceed with the standard generation workflow
    generator.generate_all_tests(file_path)
    return True

except Exception as e:
    logger.error(f&quot;Test generation failed: {e}&quot;, exc_info=True)
    return False
</code></pre></div>
<p>def main(args: Optional[list] = None) -&gt; int:
    """
    Main entry point for the test generator script.</p>
<div class="highlight"><pre><span></span><code>Args:
    args: Optional list of command line arguments. If None, uses sys.argv[1:]

Returns:
    int: Exit code (0 for success, 1 for failure)
&quot;&quot;&quot;
try:
    file_path = parse_args(args)
    success = run_test_generation(file_path)
    return 0 if success else 1

except ValueError as e:
    print(f&quot;Error: {e}&quot;)
    logger.error(f&quot;Invalid arguments: {e}&quot;)
    print(&quot;Usage: python test_generator.py &lt;path_to_python_file&gt;&quot;)
    return 1

except Exception as e:
    print(f&quot;Unexpected error: {e}&quot;)
    logger.error(&quot;Unexpected error during execution&quot;, exc_info=True)
    return 1
</code></pre></div>
<p>if <strong>name</strong> == "<strong>main</strong>":
    sys.exit(main()) is the content of the source code under test (if needed for context).</p>
<p>Output Format</p>
<p>Provide a single Python code block containing the fully refactored, consolidated test file. The output should be ready-to-run with:</p>
<p>python -m unittest</p>
<p>It must exhibit all of the improvements listed above, including:
       Logical grouping of tests,
       Clear and correct usage of setUp,
       Docstrings for test classes and methods,
       Consolidated and refactored tests (no duplicates),
       Robust assertions and coverage,
       Use of hypothesis with one or more examples,
       Use of mock where appropriate.</p>
<h1 id="_1"></h1>
<p>EXTRA USEFUL CONTEXT TO AID YOU IN YOUR TASK:
Hypothesis: A Comprehensive Best-Practice and Reference Guide</p>
<p>Hypothesis is a powerful property-based testing library for Python, designed to help you find subtle bugs by generating large numbers of test inputs and minimizing failing examples. This document combines the strengths and core ideas of three earlier guides. It serves as a broad, in-depth resource: covering Hypothesis usage from the basics to advanced methods, including background on its internal mechanisms (Conjecture) and integration with complex workflows.</p>
<p></p>
<p>Table of Contents
    1.  Introduction to Property-Based Testing
1.1 What Is Property-Based Testing?
1.2 Why Use Property-Based Testing?
1.3 Installing Hypothesis
    2.  First Steps with Hypothesis
2.1 A Simple Example
2.2 Basic Workflows and Key Concepts
2.3 Troubleshooting the First Failures
    3.  Core Hypothesis Concepts
3.1 The @given Decorator
3.2 Strategies: Building and Composing Data Generators
3.3 Shrinking and Minimizing Failing Examples
3.4 Example Database and Replay
    4.  Advanced Data Generation
4.1 Understanding Strategies vs. Types
4.2 Composing Strategies (map, filter, flatmap)
4.3 Working with Complex or Recursive Data
4.4 Using @composite Functions
4.5 Integration and Edge Cases
    5.  Practical Usage Patterns
5.1 Testing Numeric Code (Floating-Point, Bounds)
5.2 Text and String Generation (Character Sets, Regex)
5.3 Dates, Times, and Time Zones
5.4 Combining Hypothesis with Fixtures and Other Test Tools
    6.  Stateful/Model-Based Testing
6.1 The RuleBasedStateMachine and @rule Decorators
6.2 Designing Operations and Invariants
6.3 Managing Complex State and Multiple Bundles
6.4 Example: Testing a CRUD System or Other Stateful API
    7.  Performance and Health Checks
7.1 Diagnosing Slow Tests with Deadlines
7.2 Common Health Check Warnings and Their Meanings
7.3 Filtering Pitfalls (assume / Over-Filters)
7.4 Tuning Hypothesis Settings (max_examples, phases, etc.)
7.5 Speed vs. Thoroughness
    8.  Multiple Failures and Multi-Bug Discovery
8.1 How Hypothesis Detects and Distinguishes Bugs
8.2 Typical Bug Slippage and the Threshold Problem
8.3 Strategies for Handling Multiple Distinct Failures
    9.  Internals: The Conjecture Engine
9.1 Overview of Bytestream-Based Generation
9.2 Integrated Shrinking vs. Type-Based Shrinking
9.3 How Conjecture Tracks and Minimizes Examples
9.4 The Example Database in Depth
    10. Hypothesis in Real-World Scenarios
10.1 Using Hypothesis in CI/CD
10.2 Collaborative Testing in Teams
10.3 Integrating with Other Tools (pytest, coverage, etc.)
10.4 Best Practices for Large Projects
    11. Extensibility and Advanced Topics
11.1 Third-Party Extensions (e.g., Hypothesis-Bio, Hypothesis-NetworkX)
11.2 Targeted Property-Based Testing (Scoring)
11.3 Hybrid Approaches (Combining Examples with Generation)
11.4 Glass-Box Testing and Potential Future Work
    12. Troubleshooting and FAQs
12.1 Common Error Messages
12.2 Reproduce Failures with @reproduce_failure and Seeds
12.3 Overcoming Flaky or Non-Deterministic Tests
12.4 Interpreting Statistics
    13. Summary and Further Reading
13.1 Key Takeaways and Next Steps
13.2 Recommended Resources and Papers
13.3 Contributing to Hypothesis</p>
<p></p>
<ol>
<li>Introduction to Property-Based Testing</li>
</ol>
<p>1.1 What Is Property-Based Testing?</p>
<p>Property-based testing (PBT) shifts your focus from manually enumerating test inputs to describing the properties your code should fulfill for all valid inputs. Instead of hardcoding specific examples (like assert f(2) == 4), you define requirements: e.g., Sorting a list is idempotent. Then the library (Hypothesis) generates test inputs to find edge cases or scenarios violating those properties.</p>
<p>Example</p>
<p>from hypothesis import given, strategies as st</p>
<p>@given(st.lists(st.integers()))
def test_sort_idempotent(xs):
    once = sorted(xs)
    twice = sorted(once)
    assert once == twice</p>
<p>Hypothesis tries diverse lists (including empty lists, duplicates, large sizes, negative or positive numbers). If something fails, it shrinks the input to a minimal failing example.</p>
<p>1.2 Why Use Property-Based Testing?
       Coverage of Edge Cases: Automatically covers many corner casesempty inputs, large values, special floats, etc.
       Reduced Manual Labor: You specify broad properties, and the tool handles enumerations.
       Debugging Aid: Found a failing input? Hypothesis shrinks it to a simpler version, making debug cycles shorter.
       Less Test Boilerplate: Fewer individual test cases to write while achieving higher coverage.</p>
<p>1.3 Installing Hypothesis</p>
<p>You can install the base library with pip install hypothesis. For specialized extras (e.g., date/time, Django), consult Hypothesis extras docs.</p>
<p></p>
<ol>
<li>First Steps with Hypothesis</li>
</ol>
<p>2.1 A Simple Example</p>
<p>from hypothesis import given
from hypothesis.strategies import integers</p>
<p>@given(integers())
def test_square_is_nonnegative(x):
    assert x*x &gt;= 0</p>
<p>Run with pytest, unittest, or another runner. Hypothesis calls test_square_is_nonnegative multiple times with varied integers (positive, negative, zero).</p>
<p>2.2 Basic Workflows and Key Concepts
    1.  Test Functions: Decorate with @given(<strategies>).
    2.  Generation and Execution: Hypothesis runs tests many times with random values, tries to find failures.
    3.  Shrinking: If a failure occurs, Hypothesis narrows down (shrinks) the input to a minimal failing example.</p>
<p>2.3 Troubleshooting the First Failures
       Assertion Errors: If you see Falsifying example: ..., Hypothesis found a failing scenario. Use that scenario to fix your code or refine your property.
       Health Check Warnings: If you see warnings like filter_too_much or too_slow, see the Health Checks section.</p>
<p></p>
<ol>
<li>Core Hypothesis Concepts</li>
</ol>
<p>3.1 The @given Decorator</p>
<p>@given ties strategies to a test functions parameters:</p>
<p>from hypothesis import given
from hypothesis.strategies import text, emails</p>
<p>@given(email=emails(), note=text())
def test_process_email(email, note):
    ...</p>
<p>Hypothesis calls test_process_email() repeatedly with random emails and text. If everything passes, the test is green. Otherwise, you get a shrunk failing example.</p>
<p>3.2 Strategies: Building and Composing Data Generators</p>
<p>Hypothesiss data generation revolves around strategies. Basic ones:
       integers(), floats(), text(), booleans(), etc.
       Containers: lists(elements, ...), dictionaries(keys=..., values=...)
       Map/Filter: Transform or constrain existing strategies.
       Composite: Build custom strategies for domain objects.</p>
<p>3.3 Shrinking and Minimizing Failing Examples</p>
<p>If a test fails on a complicated input, Hypothesis tries simpler versions: removing elements from lists, changing large ints to smaller ints, etc. The final reported failing input is minimal by lex ordering.</p>
<p>Falsifying example: test_sort_idempotent(xs=[2, 1, 1])</p>
<p>Hypothesis might have started with [random, complicated list] but ended with [2,1,1].</p>
<p>3.4 Example Database and Replay</p>
<p>Failures are saved in a local .hypothesis/ directory. On subsequent runs, Hypothesis replays known failing inputs before generating fresh ones. This ensures consistent reporting once a failing case is discovered.</p>
<p></p>
<ol>
<li>Advanced Data Generation</li>
</ol>
<p>4.1 Understanding Strategies vs. Types</p>
<p>Hypothesis does not rely solely on type information. You can define custom constraints to ensure the data you generate matches your domain. E.g., generating only non-empty lists or restricting floats to finite values:</p>
<p>import math</p>
<p>@given(st.lists(st.floats(allow_infinity=False, allow_nan=False), min_size=1))
def test_mean_in_bounds(xs):
    avg = sum(xs)/len(xs)
    assert min(xs) &lt;= avg &lt;= max(xs)</p>
<p>4.2 Composing Strategies (map, filter, flatmap)
       map(f) transforms data after generation:</p>
<p>even_integers = st.integers().map(lambda x: x * 2)</p>
<div class="highlight"><pre><span></span><code>   filter(pred) discards values that fail pred; be mindful of over-filtering performance.
   flatmap(...) draws a value, then uses it to define a new strategy:
</code></pre></div>
<h1 id="draw-an-int-n-then-a-list-of-length-n">Draw an int n, then a list of length n</h1>
<p>st.integers(min_value=0, max_value=10).flatmap(lambda n: st.lists(st.text(), min_size=n, max_size=n))</p>
<p>4.3 Working with Complex or Recursive Data</p>
<p>For tree-like or nested data, use st.recursive(base_strategy, extend_strategy, max_leaves=...) to limit growth. Also consider the @composite decorator to build logic step by step.</p>
<p>from hypothesis import strategies as st, composite</p>
<p>@composite
def user_records(draw):
    name = draw(st.text(min_size=1))
    age = draw(st.integers(min_value=0))
    return "name": name, "age": age</p>
<p>4.4 Using @composite Functions</p>
<p>@composite is a more explicit style than map/flatmap. It helps define multi-step draws within one function. Its usually simpler for highly interdependent data.</p>
<p>4.5 Integration and Edge Cases
       Ensuring Valid Domain Data: Use composites or partial filtering. Overuse of filter(...) can cause slow tests and health-check failures.
       Large/Complex Structures: Limit sizes or use constraints (max_size, bounding integers, etc.) to avoid timeouts.</p>
<p></p>
<ol>
<li>Practical Usage Patterns</li>
</ol>
<p>5.1 Testing Numeric Code (Floating-Point, Bounds)</p>
<p>Floating point nuances:</p>
<p>@given(st.floats(allow_nan=False, allow_infinity=False))
def test_floats(x):
    ...</p>
<p>Constrain or skip NaNs/infinities if your domain doesnt handle them. Keep an eye on overflows if sums get large.</p>
<p>5.2 Text and String Generation (Character Sets, Regex)</p>
<p>Hypothesis can generate ASCII, Unicode, or custom sets:</p>
<p>from hypothesis.strategies import text</p>
<p>@given(text(alphabet="ABCDE", min_size=1))
def test_some_text(s):
    assert s[0] in "ABCDE"</p>
<p>Or use from_regex(r"MyPattern") for more specialized scenarios.</p>
<p>5.3 Dates, Times, and Time Zones</p>
<p>Install hypothesis[datetime] for strategies like dates(), datetimes(), timezones(). These handle cross-timezone issues or restricted intervals.</p>
<p>5.4 Combining Hypothesis with Fixtures and Other Test Tools</p>
<p>With pytest, you can pass both fixture arguments and Hypothesis strategy arguments:</p>
<p>import pytest</p>
<p>@pytest.fixture
def db():
    return init_db()</p>
<p>@given(x=st.integers())
def test_db_invariant(db, x):
    assert my_query(db, x) == ...</p>
<p>Function-scoped fixtures are invoked once per test function, not per example, so plan accordingly or do manual setup for each iteration.</p>
<p></p>
<ol>
<li>Stateful/Model-Based Testing</li>
</ol>
<p>6.1 The RuleBasedStateMachine and @rule Decorators</p>
<p>For testing stateful systems, Hypothesis uses a rule-based approach:</p>
<p>from hypothesis.stateful import RuleBasedStateMachine, rule</p>
<p>class SimpleCounter(RuleBasedStateMachine):
    def <strong>init</strong>(self):
        super().<strong>init</strong>()
        self.counter = 0</p>
<div class="highlight"><pre><span></span><code>@rule(increment=st.integers(min_value=1, max_value=100))
def inc(self, increment):
    self.counter += increment
    assert self.counter &gt;= 0
</code></pre></div>
<p>TestCounter = SimpleCounter.TestCase</p>
<p>Hypothesis runs random sequences of operations, checking for invariant violations.</p>
<p>6.2 Designing Operations and Invariants
       Each @rule modifies the system under test.
       Use @precondition to ensure certain rules only fire in valid states.
       Use @invariant to check conditions after each rule.</p>
<p>6.3 Managing Complex State and Multiple Bundles
       Bundle(...) helps track created objects and pass them between rules.
       Perfect for simulating CRUD or multi-object interactions.</p>
<p>6.4 Example: Testing a CRUD System or Other Stateful API</p>
<p>class CRUDSystem(RuleBasedStateMachine):
    Records = Bundle('records')</p>
<div class="highlight"><pre><span></span><code>@rule(target=Records, data=st.text())
def create(self, data):
    record_id = my_create_fn(data)
    return record_id

@rule(record=Records)
def delete(self, record):
    my_delete_fn(record)
</code></pre></div>
<p>Hypothesis will produce sequences of create/delete calls. If a bug arises, it provides a minimal sequence reproducing it.</p>
<p></p>
<ol>
<li>Performance and Health Checks</li>
</ol>
<p>7.1 Diagnosing Slow Tests with Deadlines</p>
<p>Hypothesis can treat slow examples as errors:</p>
<p>from hypothesis import settings, HealthCheck</p>
<p>@settings(deadline=100)  # 100ms deadline
@given(st.lists(st.integers()))
def test_something(xs):
    ...</p>
<p>If a single test run exceeds 100 ms, it raises DeadlineExceeded. This helps identify performance bottlenecks quickly.</p>
<p>7.2 Common Health Check Warnings and Their Meanings
       filter_too_much: A large proportion of generated data is being thrown away. Fix by refining your strategy or combining strategies (instead of heavy use of filter).
       too_slow: The test or generation logic is slow. Lower max_examples or investigate your codes performance.
       data_too_large: Possibly generating very large structures. Restrict sizes.</p>
<p>7.3 Filtering Pitfalls (assume / Over-Filters)</p>
<p>Using assume(condition) forcibly discards any example that doesnt meet condition. Overdoing it can degrade performance drastically. Instead, refine your data strategies:</p>
<h1 id="instead-of">Instead of:</h1>
<p>@given(st.lists(st.integers()).filter(lambda xs: sum(xs) &lt; 100))</p>
<h1 id="use-a-better-approach">Use a better approach:</h1>
<p>@given(st.lists(st.integers(max_value=100), max_size=10))</p>
<p>7.4 Tuning Hypothesis Settings (max_examples, phases, etc.)
       max_examples: Controls how many examples are generated per test (default ~200).
       phases: Choose which parts of the test lifecycle (e.g. shrink, reuse) run.
       suppress_health_check: Silence known but acceptable warnings.</p>
<p>7.5 Speed vs. Thoroughness</p>
<p>Balance thorough coverage with test suite runtime. Trim unhelpful extra complexity in data generation. Use deadline or lower max_examples for large test suites.</p>
<p></p>
<ol>
<li>Multiple Failures and Multi-Bug Discovery</li>
</ol>
<p>8.1 How Hypothesis Detects and Distinguishes Bugs</p>
<p>Hypothesis typically shrinks until it finds the smallest failing example. But if a test can fail in multiple ways, Hypothesis 3.29+ tries to keep track of each distinct bug (by exception type and line number).</p>
<p>8.2 Typical Bug Slippage and the Threshold Problem
       Bug Slippage: Starting with one bug scenario but shrinking to a different scenario. Hypothesis tries to keep track and track distinct failures.
       Threshold Problem: When tests fail due to crossing a numeric threshold, shrunk examples tend to be just barely beyond that threshold, potentially obscuring the severity of the issue. Techniques to mitigate this can involve targeting or custom test logic.</p>
<p>8.3 Strategies for Handling Multiple Distinct Failures</p>
<p>Hypothesiss multi-failure mode ensures it shrinks each failing scenario independently. You may see multiple minimal failures reported. This can be turned on automatically if distinct bug states are detected.</p>
<p></p>
<ol>
<li>Internals: The Conjecture Engine</li>
</ol>
<p>9.1 Overview of Bytestream-Based Generation</p>
<p>Conjecture is the underlying fuzzing engine. It treats every generated example as a lazily consumed byte stream. Strategies interpret segments of bytes as integers, floats, text, etc. This uniform approach:
       Simplifies storing known failures to replay them.
       Allows integrated shrinking by reducing or rewriting parts of the byte stream.</p>
<p>9.2 Integrated Shrinking vs. Type-Based Shrinking</p>
<p>Old or simpler property-based systems often rely on type-based shrinking. Conjectures approach integrates shrinking with data generation. This ensures that if you build data by composition (e.g. mapping or flattening strategies), Hypothesis can still shrink effectively.</p>
<p>9.3 How Conjecture Tracks and Minimizes Examples
       Each test run has a buffer of bytes.
       On failure, Conjecture tries different transformations (removing or reducing bytes).
       The result is simpler failing input but consistent with the constraints of your strategy.</p>
<p>9.4 The Example Database in Depth</p>
<p>All interesting examples get stored in .hypothesis/examples by default. On re-run, Hypothesis tries these before generating new data. This yields repeatable failures for regression testsespecially helpful in CI setups.</p>
<p></p>
<ol>
<li>Hypothesis in Real-World Scenarios</li>
</ol>
<p>10.1 Using Hypothesis in CI/CD
       Run Hypothesis-based tests as part of your continuous integration.
       The example database can be committed to share known failures across devs.
       Set a deadline or use smaller max_examples to keep test times predictable.</p>
<p>10.2 Collaborative Testing in Teams
       Consistent Strategy Definitions: Keep your custom strategies in a shared strategies.py.
       Version Control: The .hypothesis directory can be versioned to share known failing examples, though watch out for merge conflicts.</p>
<p>10.3 Integrating with Other Tools (pytest, coverage, etc.)
       Pytest integration is seamlessjust write @given tests, run pytest.
       Coverage tools measure tested code as usual, but remember Hypothesis can deeply cover corner cases.</p>
<p>10.4 Best Practices for Large Projects
       Modular Strategies: Break them down for maintainability.
       Tackle Invariants Early: Short-circuit with assume() or well-structured strategies.
       Monitor Performance: Use health checks, deadlines, and max_examples config to scale.</p>
<p></p>
<ol>
<li>Extensibility and Advanced Topics</li>
</ol>
<p>11.1 Third-Party Extensions
       hypothesis-bio: Specialized for bioinformatics data formats.
       hypothesis-networkx: Generate networkx graphs, test graph algorithms.
       Many more unofficial or domain-specific libraries exist. Creating your own extension is easy.</p>
<p>11.2 Targeted Property-Based Testing (Scoring)</p>
<p>You can guide test generation by calling target(score) in your code. Hypothesis tries to evolve test cases with higher scores, focusing on interesting or extreme behaviors (like maximizing error metrics).</p>
<p>from hypothesis import given, target
from hypothesis.strategies import floats</p>
<p>@given(x=floats(-1e6, 1e6))
def test_numerical_stability(x):
    err = some_error_metric(x)
    target(err)
    assert err &lt; 9999</p>
<p>11.3 Hybrid Approaches (Combining Examples with Generation)</p>
<p>You can add example-based tests to complement property-based ones. Also, you can incorporate real-world test data as seeds or partial strategies.</p>
<p>11.4 Glass-Box Testing and Potential Future Work</p>
<p>Hypothesis largely treats tests as a black box but can be extended with coverage data or other instrumentation for more advanced test generation. This is an open area of R&amp;D.</p>
<p></p>
<ol>
<li>Troubleshooting and FAQs</li>
</ol>
<p>12.1 Common Error Messages
       Unsatisfiable: Hypothesis cant find enough valid examples. Possibly an over-filter or an unrealistic requirement.
       DeadlineExceeded: Your test or code is too slow for the set deadline ms.
       FailedHealthCheck: Usually means youre doing too much filtering or the example is too large.</p>
<p>12.2 Reproduce Failures with @reproduce_failure and Seeds</p>
<p>If Hypothesis cant express your failing data via a standard repr, it shows a snippet like:</p>
<p>@reproduce_failure('3.62.0', b'...')
def test_something():
    ...</p>
<p>Adding that snippet ensures the bug is replayed exactly. Alternatively, you can do:</p>
<p>from hypothesis import seed</p>
<p>@seed(12345)
@given(st.integers())
def test_x(x):
    ...</p>
<p>But seeds alone are insufficient if your .hypothesis database is relevant or if your test uses inline data.</p>
<p>12.3 Overcoming Flaky or Non-Deterministic Tests</p>
<p>If code is time-sensitive or concurrency-based, you may see spurious failures. Try limiting concurrency, raising deadlines, or disabling shrinking for certain tests. Alternatively, fix the non-determinism in the tested code.</p>
<p>12.4 Interpreting Statistics</p>
<p>Running pytest --hypothesis-show-statistics yields info on distribution of generated examples, data-generation time vs. test time, etc. This helps find bottlenecks, excessive filtering, or unexpectedly large inputs.</p>
<p></p>
<ol>
<li>Summary and Further Reading</li>
</ol>
<p>13.1 Key Takeaways and Next Steps
       Write Clear Properties: A crisp property is simpler for Hypothesis to exploit.
       Refine Strategies: Good strategy design yields fewer discards and faster tests.
       Use Health Checks: They highlight anti-patterns early.
       Explore Stateful Testing: Perfect for integration tests or persistent-state bugs.</p>
<p>13.2 Recommended Resources and Papers
       Official Hypothesis Documentation
       QuickCheck papers: Claessen and Hughes, 2000
       Testingreduction synergy: Regehr et al. Test-case Reduction via Delta Debugging (PLDI 2012)
       Hypothesis: A New Approach to Property-Based Testing (HypothesisWorks website)</p>
<p>13.3 Contributing to Hypothesis</p>
<p>Hypothesis is open source. If you have ideas or find issues:
       Check our GitHub repo
       Read the Contributing Guide
       Every improvement is welcomeddocumentation, bug reports, or code!</p>
<p></p>
<p>Final Thoughts</p>
<p>We hope this unified, comprehensive guide helps you unlock the power of Hypothesis. From quick introductions to advanced stateful testing, from performance pitfalls to internal design details, you now have a toolkit for robust property-based testing in Python.</p>
<p>Happy testing! If you run into any questions, re-check the relevant sections here or visit the community resources. Once you incorporate Hypothesis into your testing workflow, you might find hidden bugs you never anticipatedand thats the point!</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.7a47a382.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.e71a0d61.min.js"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>