"""
Test script for the fixed initialize_features_from_config function.
This script tests the fix for the tensor size mismatch issue in Stage D.
"""
import torch
import logging
import sys
from omegaconf import OmegaConf
from hypothesis import given, strategies as st
import numpy as np

# Define error identifiers for better debugging
ERR_MISSING_CONFIG = "ERR-STAGED-CONFIG-001"  # Missing configuration parameters
ERR_MISSING_METADATA = "ERR-STAGED-METADATA-001"  # Missing atom metadata
ERR_SHAPE_MISMATCH = "ERR-STAGED-SHAPE-001"  # Shape mismatch in tensors
ERR_RESIDUE_COUNT = "ERR-STAGED-RESIDUE-001"  # Incorrect residue count

# Configure logging
logging.basicConfig(level=logging.INFO, format='[%(asctime)s][%(name)s][%(levelname)s] - %(message)s')
log = logging.getLogger(__name__)

# Import the function we want to test
from rna_predict.pipeline.stageD.run_stageD import initialize_features_from_config

def create_test_config():
    """Create a test configuration with the necessary settings."""
    config_dict = {
        "model": {
            "stageD": {
                # Add required parameters that were missing
                "ref_element_size": 128,
                "ref_atom_name_chars_size": 256,
                "profile_size": 32,  # Added missing profile_size parameter
                "input_features": {
                    "atom_to_token_idx": {
                        "repeats": 44  # Standard RNA residue has ~44 atoms
                    },
                    "profile": {
                        "size": [32]  # Example size for profile embeddings
                    }
                }
            }
        }
    }
    return OmegaConf.create(config_dict)

@given(num_atoms=st.integers(min_value=1, max_value=43))
def test_with_small_atom_count(num_atoms):
    """Test the function with a small number of atoms (less than atoms_per_residue).

    Args:
        num_atoms: Number of atoms to test with (generated by Hypothesis)
    """
    batch_size = 1
    # Generate random coordinates using Hypothesis
    coords_np = np.random.randn(batch_size, num_atoms, 3).astype(np.float32)
    coords = torch.tensor(coords_np)

    # Create test config
    cfg = create_test_config()

    # Create atom_metadata with residue_indices
    # All atoms belong to residue 0 since we have fewer atoms than atoms_per_residue
    atom_metadata = {
        "residue_indices": torch.zeros(num_atoms, dtype=torch.long)
    }

    # Call the function with atom_metadata
    log.info(f"Testing initialize_features_from_config with {num_atoms} atoms")
    try:
        features = initialize_features_from_config(cfg, coords, atom_metadata)
    except ValueError as e:
        if "residue_indices" in str(e):
            raise ValueError(f"{ERR_MISSING_METADATA}: {str(e)}") from e
        elif "required parameter" in str(e):
            raise ValueError(f"{ERR_MISSING_CONFIG}: {str(e)}") from e
        else:
            raise

    # Check the results
    log.info(f"atom_to_token_idx shape: {features['atom_to_token_idx'].shape}")

    # Verify that atom_to_token_idx has the correct shape
    assert features["atom_to_token_idx"].shape == (batch_size, num_atoms), \
        f"{ERR_SHAPE_MISMATCH}: Expected shape {(batch_size, num_atoms)}, got {features['atom_to_token_idx'].shape}"

    # Verify that all atoms are mapped to residue 0
    assert (features["atom_to_token_idx"] == 0).all(), \
        f"{ERR_RESIDUE_COUNT}: Expected all atoms to be mapped to residue 0"

    log.info("Test passed!")

@given(num_residues=st.integers(min_value=2, max_value=5))
def test_with_normal_atom_count(num_residues):
    """Test the function with a normal number of atoms (divisible by atoms_per_residue).

    Args:
        num_residues: Number of residues to test with (generated by Hypothesis)
    """
    batch_size = 1
    atoms_per_residue = 44  # Standard RNA residue has ~44 atoms
    num_atoms = num_residues * atoms_per_residue

    # Generate random coordinates using Hypothesis
    coords_np = np.random.randn(batch_size, num_atoms, 3).astype(np.float32)
    coords = torch.tensor(coords_np)

    # Create test config
    cfg = create_test_config()

    # Create atom_metadata with residue_indices
    # Each set of atoms_per_residue atoms belongs to a different residue
    residue_indices = torch.cat([
        torch.full((atoms_per_residue,), i, dtype=torch.long) for i in range(num_residues)
    ])
    atom_metadata = {
        "residue_indices": residue_indices
    }

    # Call the function with atom_metadata
    log.info(f"Testing initialize_features_from_config with {num_atoms} atoms ({num_residues} residues)")
    try:
        features = initialize_features_from_config(cfg, coords, atom_metadata)
    except ValueError as e:
        if "residue_indices" in str(e):
            raise ValueError(f"{ERR_MISSING_METADATA}: {str(e)}") from e
        elif "required parameter" in str(e):
            raise ValueError(f"{ERR_MISSING_CONFIG}: {str(e)}") from e
        else:
            raise

    # Check the results
    log.info(f"atom_to_token_idx shape: {features['atom_to_token_idx'].shape}")
    log.info(f"atom_to_token_idx unique values: {torch.unique(features['atom_to_token_idx'])}")

    # Verify that atom_to_token_idx has the correct shape
    assert features["atom_to_token_idx"].shape == (batch_size, num_atoms), \
        f"{ERR_SHAPE_MISMATCH}: Expected shape {(batch_size, num_atoms)}, got {features['atom_to_token_idx'].shape}"

    # Verify that atoms are mapped to the correct residues
    expected_residues = set(range(num_residues))
    actual_residues = set(torch.unique(features["atom_to_token_idx"]).tolist())
    assert actual_residues == expected_residues, \
        f"{ERR_RESIDUE_COUNT}: Expected residues {expected_residues}, got {actual_residues}"

    log.info("Test passed!")

@given(
    num_full_residues=st.integers(min_value=1, max_value=3),
    remainder_atoms=st.integers(min_value=1, max_value=43)
)
def test_with_non_divisible_atom_count(num_full_residues, remainder_atoms):
    """Test the function with a non-divisible number of atoms.

    Args:
        num_full_residues: Number of full residues (generated by Hypothesis)
        remainder_atoms: Number of remaining atoms (generated by Hypothesis)
    """
    batch_size = 1
    atoms_per_residue = 44  # Standard RNA residue has ~44 atoms
    num_atoms = num_full_residues * atoms_per_residue + remainder_atoms

    # Generate random coordinates using Hypothesis
    coords_np = np.random.randn(batch_size, num_atoms, 3).astype(np.float32)
    coords = torch.tensor(coords_np)

    # Create test config
    cfg = create_test_config()

    # Create atom_metadata with residue_indices
    # First atoms_per_residue*num_full_residues atoms belong to residues 0 to num_full_residues-1,
    # and the remaining remainder_atoms atoms belong to residue num_full_residues
    residue_indices = torch.cat([
        torch.cat([torch.full((atoms_per_residue,), i, dtype=torch.long) for i in range(num_full_residues)]),
        torch.full((remainder_atoms,), num_full_residues, dtype=torch.long)
    ])
    atom_metadata = {
        "residue_indices": residue_indices
    }

    # Call the function with atom_metadata
    log.info(f"Testing initialize_features_from_config with {num_atoms} atoms ({num_full_residues} full residues + {remainder_atoms} atoms)")
    try:
        features = initialize_features_from_config(cfg, coords, atom_metadata)
    except ValueError as e:
        if "residue_indices" in str(e):
            raise ValueError(f"{ERR_MISSING_METADATA}: {str(e)}") from e
        elif "required parameter" in str(e):
            raise ValueError(f"{ERR_MISSING_CONFIG}: {str(e)}") from e
        else:
            raise

    # Check the results
    log.info(f"atom_to_token_idx shape: {features['atom_to_token_idx'].shape}")
    log.info(f"atom_to_token_idx unique values: {torch.unique(features['atom_to_token_idx'])}")

    # Verify that atom_to_token_idx has the correct shape
    assert features["atom_to_token_idx"].shape == (batch_size, num_atoms), \
        f"{ERR_SHAPE_MISMATCH}: Expected shape {(batch_size, num_atoms)}, got {features['atom_to_token_idx'].shape}"

    # Verify that the number of unique residue indices is correct
    num_residues = num_full_residues + 1  # We have num_full_residues + 1 residues (0 to num_full_residues)
    assert len(torch.unique(features["atom_to_token_idx"])) == num_residues, \
        f"{ERR_RESIDUE_COUNT}: Expected {num_residues} unique residue indices, got {len(torch.unique(features['atom_to_token_idx']))}"

    log.info("Test passed!")

if __name__ == "__main__":
    try:
        # Run the tests using pytest with Hypothesis
        # Note: When running directly, we use a simplified approach
        # For full Hypothesis testing, use pytest from the command line

        # Create some example inputs for direct testing
        test_with_small_atom_count(21)  # Test with 21 atoms
        test_with_normal_atom_count(2)  # Test with 2 residues
        test_with_non_divisible_atom_count(2, 12)  # Test with 2 full residues + 12 atoms

        log.info("All tests passed!")
    except Exception as e:
        log.error(f"Test failed: {str(e)}")
        sys.exit(1)
